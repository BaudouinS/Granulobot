/*Granulobot UDP Firmware V13 
 * Encoder position measurement and conversion in angle and angular velocity
 * Magnet's magnetic field measurement
 * accel + gyr measurement
 * PWM Control of N20 geared motors
 * 2 ways UDP wifi communication with broadcasting address
 * PID on position encoder  https://github.com/DonnyCraft1/PIDArduino
 * https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller
 *  OTA wireless firmware upload: https://randomnerdtutorials.com/esp32-over-the-air-ota-programming/

*      autoselect particule address from database defined in header {IP address number(last digits),paticule adress number}
* New on V13:
*      ??????????
*
*components controlled by the firmware:
*
*accel+gyro: LSM6DSOX 
*magnetic sensor: Tlv493d (+-150mT)
*magnetic encoder: Pololu
*Motor driver: DRV8833
*Microcontroller: ESP32
*StepUp motor: TPS61178 (with Enable Pin)
*
*OpenStageControl ressources:
*https://openstagecontrol.ammd.net/docs/custom-module/custom-module/
*
*by Baudouin Saintyves
*October 28th 2021
*
* Data generated by the robot:
* "{"A":1,"t":97768,"d":5,"x":0.052642,"y":-0.095713,"z":9.818948,"u":0.001222,"v":0.00733,"w":-0.006109}"
*
*/

////////////////////////////////////
/////USER PARAMETERS//////////////////

/* WiFi network name and password */
const char * ssid = "TP-Link_C1BA";
const char * pwd = "93409582";
//const char * ssid = "NETGEAR21";
//const char * pwd = "strongmoon546";
//const char * ssid = "gbots";
//const char * pwd = "gbotsRus";
//const char * ssid = "HOME-26E2";
//const char * pwd = "baked7744borrow";

////add here new two last characters of Mac Address. //Particule number 
 char *ADDRESS_DATA_BASE[] = {  //
    "FC",//1
    "08",//2
    "20",//3
    "78",//4
    "38",//5
    "4C",//6
    "E8",//7
    "60",//8
    "54",//9
    //add new particule here
    "00"
    };
  
//choose here the motor's gear ratio
 const int ratio=380;

//choose here the motor's PID parameters
#define __Kp 260//260 // Proportional constant
#define __Ki 2.7 // Integral Constant
#define __Kd 2000//2000 // Derivative Constant

//choose here motor's PWM frequency
#define FREQ 100
////////////////////////////////////
////////////////////////////////////

////////////////////////////////////
/////LIBRARIES//////////////////////

 //Arduino
#include <Arduino.h>

  //Wifi
#include <WiFi.h>
#include <WiFiUdp.h>
#include <ESPmDNS.h>
#include <ArduinoOTA.h> //library for Over The Air programming

  //sensors
#include <Adafruit_Sensor.h>
#include <Adafruit_LSM6DSOX.h>//accel+gyro
#include <Adafruit_LSM6DS.h>//accel+gyro
#include <Tlv493d.h>//magnetic field sensor

  //packet format and parsing for serial com
#include <Regexp.h>
#include <ArduinoJson.h> // tuto https://arduinojson.org/v6/doc/serialization/

  //TinyPico Helper Library
#include <TinyPICO.h>

// //OSC library     https://github.com/CNMAT/OSC
#include <OSCMessage.h> 
#include <OSCBundle.h>
#include <OSCData.h>

  //PID library
#include <PIDController.h> // https://github.com/DonnyCraft1/PIDArduino

  
////////////////////////////////////
/////PIN DEFINE/////////////////////

// Battery
#define BAT_CHARGE 34
#define BAT_VOLTAGE 35

//Encoder
#define ENCODER_A 5
#define ENCODER_B 14

//MOTOR
// Define the pin numbers on which the outputs are generated.
#define MOT_A1_PIN 25//15
#define MOT_A2_PIN 27//14
#define MOT_SLP_PIN 18

//Boost 3.7 to 6V
#define EN_BOOST 33//SLEEP pin on BOOST
/////////////////////////////////////

////////////////////////////////////
/////VARIABLES//////////////////////


// IP address to send UDP data to.
// it can be ip address of the server or 
// a network broadcast address
// here is broadcast address
const char * udpAddress = "192.168.1.255";
//const char * udpAddress = "192.168.0.255"; //broadcasting address= the program will read from this address
//const char * udpAddress = "192.168.0.109"; //255"; //broadcasting address= the program will read from this address
//const char * PadAddress = "192.168.0.100";
//const char * udpAddress = "10.0.0.255"; //broadcasting address= the program will read from this address
//const char * PadAddress = "10.0.0.15";
const int localPort = 6808;//4210;
const int outPort = 6807;
//byte local[6];   //store mac address

////particule address number
//int ADDRESS_NUM;

//counter for poke function
int CountPoke=0;

 //Timers
unsigned long previousMillis1 = 0; // store previous millis readout (for PID)
unsigned long previousMillis2 = 0; // store previous millis readout (to send motor.angle)
unsigned long previousMillis3 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis4 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis5 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis6 = 0; // store previous millis readout (to send Bat level)

//Encoder
volatile int encoder_count=0;
int encoder_count_prev=0;
int encoder_start;
//int prev_count=0;
volatile bool CW;
volatile bool Soft;
const int tour=ratio*12;
const int Res_speed=30;//in ms
int prev_pos=0;
long int speed_tick;
float speed_rad;
int angle_tick=0;
float angle_rad=0;
int speed_target=0;
int direct=0;
int previous=0;
int direct_rec=0;
int k=0;//spring potential
int theta_0=0;

unsigned int angle_target = 0; // stores the incoming serial value. Max value is 65535
char incomingByte; // parses and stores each individual character one by one
//int motor_pwm_value = 255; // after PID computation data is stored in this variable.


struct Button {
  const uint8_t PIN;
  //uint32_t encoder_count;
  bool detect;
};

Button MA = {ENCODER_A, false};//Encoder OUT A
Button MB = {ENCODER_B, false};//Encoder OUT B


//Motor control

//global variables
bool MoveStop=false;
// setting PWM properties
const int freq = FREQ;
const int MotChannel1 = 1;
const int MotChannel2 = 2;
const int resolution = 8;

//for PID
//int motor_pwm_value = 0; // after PID computation data is stored in this variable.
unsigned int integerValue = 0;

bool Poke=false;

//for OSC Com
typedef struct Message {
  int Address;
  int Mode;
  int Torque;
  int Speed;
  int Speed_target;
  int Vshift;
  int Ashift;
  int State;
  //int Displacement;
  int Angle;
  int Angle_target;
  bool Direction;//true=CW or false=CCW
  int PWM; // after PID computation data is stored in this variable.
  bool Minus_State;
  bool Plus_State;
} Message;

int P=0;
int angle_interval;
int test_prev;
int test=0;
int encoder_Shift=0;
int encoder_count_2=0;
int encoder_count_target=0;

float ThetaG;

Message Motor;


///deep sleep
//#define BUTTON_PIN_BITMASK 0x200000000 // 2^33 in hex / for deep sleep on pin 33 with ext1
RTC_DATA_ATTR int bootCount = 0; // for deep sleep
/////////////////////////////////////

//INITIALISE
 //Initialise sensors
    // LSM6DSOX Object
Adafruit_LSM6DSOX lsm6dsox;
    // Tlv493d Object
Tlv493d Tlv493dMagnetic3DSensor = Tlv493d();
    //create PID object
PIDController pidcontroller;
PIDController pidcontroller_speed;

//create UDP instance
WiFiUDP Udp;
OSCErrorCode error;

// Initialise TinyPICO library
TinyPICO tp = TinyPICO();

//const int capacity=JSON_ARRAY_SIZE(3)+JSON_OBJECT_SIZE(1)+2*JSON_OBJECT_SIZE(3);
const int capacity = JSON_OBJECT_SIZE(9);
StaticJsonDocument<capacity> motion;

////////////////////////////////////
/////FUNCTIONS//////////////////////
void MotorOFF(){
  ledcWrite(MotChannel1, 0);
  ledcWrite(MotChannel2, 0);
  }


void motor(int power) {
  if (abs(power) > 20) {
    if (power > 0) {
      //Serial.println("Motor cw");
      ledcWrite(MotChannel1, power);
      ledcWrite(MotChannel2, 0);     
      } 
    else{
      //Serial.println("Motor ccw");
      ledcWrite(MotChannel1, 0);
      ledcWrite(MotChannel2, power);
      }
  } 
  else{
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}

void motor_cw(int power) {
  if (power > 20) {
    //Serial.println("Motor cw");
    ledcWrite(MotChannel1, power);
    ledcWrite(MotChannel2, 0);
  }
  else {
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}
void motor_ccw(int power) {
  if (power > 20) {
    //Serial.println("Motor ccw");
    ledcWrite(MotChannel2, power);
    ledcWrite(MotChannel1, 0);
  }
  else {
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}


void CONTROL_SPEED(PIDController PID, int Speed){     
    //Serial.println("control speed");
    int PWM=PID.compute(Speed);
    Serial.print("control speed, PWM= ");Serial.println(PWM);
    if (PWM > 0) // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(PWM);
    else // else we move it in a counter clockwise direction
      motor_cw(abs(PWM));  
    } 


void displaySensorDetailsISM(void) {
  Serial.print("Accelerometer range set to: ");
  switch (lsm6dsox.getAccelRange()) {
  case LSM6DS_ACCEL_RANGE_2_G:
    Serial.println("+-2G");
    break;
  case LSM6DS_ACCEL_RANGE_4_G:
    Serial.println("+-4G");
    break;
  case LSM6DS_ACCEL_RANGE_8_G:
    Serial.println("+-8G");
    break;
  case LSM6DS_ACCEL_RANGE_16_G:
    Serial.println("+-16G");
    break;
  }
  
  Serial.print("Gyro range set to: ");
  switch (lsm6dsox.getGyroRange()) {
  case LSM6DS_GYRO_RANGE_125_DPS:
    Serial.println("125 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_250_DPS:
    Serial.println("250 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_500_DPS:
    Serial.println("500 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_1000_DPS:
    Serial.println("1000 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_2000_DPS:
    Serial.println("2000 degrees/s");
    break;
  case ISM330DHCX_GYRO_RANGE_4000_DPS:
    Serial.println("4000 degrees/s");
    break;
  }

  Serial.print("Accelerometer data rate set to: ");
  switch (lsm6dsox.getAccelDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }

  Serial.print("Gyro data rate set to: ");
  switch (lsm6dsox.getGyroDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }
}
/*
Method to print the reason by which ESP32
has been awaken from sleep
*/
void print_wakeup_reason(){
  esp_sleep_wakeup_cause_t wakeup_reason;

  wakeup_reason = esp_sleep_get_wakeup_cause();

  switch(wakeup_reason)
  {
    case ESP_SLEEP_WAKEUP_EXT0 : Serial.println("Wakeup caused by external signal using RTC_IO"); break;
    case ESP_SLEEP_WAKEUP_EXT1 : Serial.println("Wakeup caused by external signal using RTC_CNTL"); break;
    case ESP_SLEEP_WAKEUP_TIMER : Serial.println("Wakeup caused by timer"); break;
    case ESP_SLEEP_WAKEUP_TOUCHPAD : Serial.println("Wakeup caused by touchpad"); break;
    case ESP_SLEEP_WAKEUP_ULP : Serial.println("Wakeup caused by ULP program"); break;
    default : Serial.printf("Wakeup was not caused by deep sleep: %d\n",wakeup_reason); break;
  }
}


/////////////////////////////////////
//attach interrupt functions for encoder
void IRAM_ATTR isr_A() {
if (digitalRead(MA.PIN) == HIGH){
    if (digitalRead(MB.PIN) == HIGH){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
else{ if (digitalRead(MB.PIN) == LOW){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }       
MA.detect = true;
}


void IRAM_ATTR isr_B() {
if (digitalRead(MB.PIN) == HIGH){
    if (digitalRead(MA.PIN) == LOW){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
else{
    if (digitalRead(MA.PIN) == HIGH){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
MB.detect = true;
}
///////////////////////////////////////////////
////////////////////////////////////////////////

void setup(){

  Wire.setClock(400000); //test 
  
  // log_d("Total heap: %d", ESP.getHeapSize());//core debug level to "verbose"
  // log_d("Free heap: %d", ESP.getFreeHeap());
  // log_d("Total PSRAM: %d", ESP.getPsramSize());
  // log_d("Free PSRAM: %d", ESP.getFreePsram());
  
  Serial.begin(115200);
  Serial.println("RESET");
  Serial.println("Firmware Granulobot UDP V13");


//WIFI UDP SETUP

  //Connect to the WiFi network
  WiFi.begin(ssid, pwd);
  Serial.println("");

  // Wait for connection
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  //This initializes udp and transfer buffer
  Udp.begin(localPort);
  Serial.print("ESP Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
  ///////


//////ARDUINO OTA 
ArduinoOTA
    .onStart([]() {
      String type;
      if (ArduinoOTA.getCommand() == U_FLASH)
        type = "sketch";
      else // U_SPIFFS
        type = "filesystem";

      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
      Serial.println("Start updating " + type);
    })
    .onEnd([]() {
      Serial.println("\nEnd");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      Serial.printf("Error[%u]: ", error);
      if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
      else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
      else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
      else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
      else if (error == OTA_END_ERROR) Serial.println("End Failed");
    });

  ArduinoOTA.begin();
  /////////////////////////////////////
//  
////  //particule address selection  
std::string EndMAC{WiFi.macAddress()[15],WiFi.macAddress()[16]};
  int index=0;
  for (int i=0; i<(sizeof(ADDRESS_DATA_BASE) / sizeof(ADDRESS_DATA_BASE[0])); i++) {
     if (EndMAC == ADDRESS_DATA_BASE[i]) {
       index = i;
       // Serial.print(local[5],HEX);
        Serial.print((sizeof(ADDRESS_DATA_BASE) / sizeof(ADDRESS_DATA_BASE[0])));Serial.print(" adresses to choose from, index: ");Serial.println(index);    
       break;
     }
  }
  IPAddress local=WiFi.localIP();

//Serial.print("Two last char of MAC address: ");Serial.println(EndMAC);

// 
 //intitialisation of Motor structure
  //Motor.Address=ADDRESS_DATA_BASE[index][1];//ADDRESS
  Motor.Address=index+1;//ADDRESS
  Motor.Mode=0;
  Motor.Speed=0;
  Motor.Speed_target=5;
  Motor.Torque=0;
  Motor.Angle=0;
  Motor.Angle_target=0;
  Motor.Direction=true;
  Motor.State=0;
  Motor.PWM=0;
  Motor.Vshift=0;
  Motor.Minus_State=false;
  Motor.Plus_State=false;
 Serial.print("Motor address:");Serial.println(Motor.Address);
  
/////deep sleep mode setup
++bootCount;
  Serial.println("Boot number: " + String(bootCount));

  //Print the wakeup reason for ESP32
  print_wakeup_reason();

  /*
  First we configure the wake up source
  We set our ESP32 to wake up for an external trigger.
  There are two types for ESP32, ext0 and ext1 .
  ext0 uses RTC_IO to wakeup thus requires RTC peripherals
  to be on while ext1 uses RTC Controller so doesnt need
  peripherals to be powered on.
  Note that using internal pullups/pulldowns also requires
  RTC peripherals to be turned on.
  */
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_5,1); //1 = High, 0 = Low

  /////////

  tp.DotStar_SetPower(true);
  tp.DotStar_SetPixelColor(0,30,0);
  tp.DotStar_Show();
  delay(2000);
  ///turn off RGB LED power to save battery life
  tp.DotStar_SetPower(false);
  
  
  ////SETUP SENSORS
  //Tlv493d
  Tlv493dMagnetic3DSensor.begin();
  Serial.println("Tlv493d Found!");

    //LSM6DSOX

    lsm6dsox.setAccelRange(LSM6DS_ACCEL_RANGE_8_G);
    lsm6dsox.setGyroRange(LSM6DS_GYRO_RANGE_2000_DPS); 
    lsm6dsox.setAccelDataRate(LSM6DS_RATE_3_33K_HZ);
    lsm6dsox.setGyroDataRate(LSM6DS_RATE_3_33K_HZ);

  while (!Serial)
    delay(10); // will pause Zero, Leonardo, etc until serial console opens 

  Serial.println("Adafruit lsm6dsox test!");

  if(!lsm6dsox.begin_I2C(0x6A)){
    Serial.println("Failed first attempt");
    if(!lsm6dsox.begin_I2C(0x6B)){
      Serial.println("Failed to find lsm6dsox chip");
      while (1) delay(10);
    }
  }

  Serial.println("lsm6dsox Found!");

  delay(500);

    //Encoder
  pinMode(MA.PIN, INPUT);
  attachInterrupt(MA.PIN, isr_A, CHANGE);
  pinMode(MB.PIN, INPUT);
  attachInterrupt(MB.PIN, isr_B, CHANGE);
  Serial.print("ticks per tour=");Serial.println(tour);
  ////////


  //ENABLE BOOST
  pinMode(EN_BOOST, OUTPUT);
  digitalWrite(EN_BOOST, HIGH);// Start with Boost on.  

  //MOTOR SETUP
    //Initialize the motor driver switch pin.
  pinMode(MOT_SLP_PIN, OUTPUT);
  digitalWrite(MOT_SLP_PIN, HIGH);// Start with drivers on.
    //PWM setup 
  ledcSetup(MotChannel1, freq, resolution);
  ledcSetup(MotChannel2, freq, resolution);

  ledcAttachPin(MOT_A1_PIN, MotChannel1);
  ledcAttachPin(MOT_A2_PIN, MotChannel2);
  ///////
  
  //PID
  pidcontroller.begin(); // initialize the PID instance
  pidcontroller.tune(__Kp,__Ki,__Kd); // Tune the PID, arguments: kP, kI, kD
  pidcontroller.limit(-100, 100); // Limit the PID output between -255 to 255, this is important to get rid of integral windup!


  //PID speed
  pidcontroller_speed.begin(); // initialize the PID instance
  pidcontroller_speed.tune(__Kp,__Ki,__Kd); // Tune the PID, arguments: kP, kI, kD
  pidcontroller_speed.limit(-100, 100); // Limit the PID output between -255 to 255, this is important to get rid of integral windup!



//// Get a *rough* estimate of the current battery voltage
  // If the battery is not present, the charge IC will still report it's trying to charge at X voltage
  // so it will still show a voltage.
  Serial.print("Battery level: ");
  Serial.println(tp.GetBatteryVoltage());
  Serial.print("Battery charging in progress: ");
  Serial.println(tp.IsChargingBattery());  
  delay(2000);
  Serial.print("battery level= ");Serial.print(((tp.GetBatteryVoltage()-3.5)/0.70)*100);Serial.println("%");

// hello for UDP, no OSC version
//  Udp.beginPacket(udpAddress,outPort);
//  Udp.printf("Hello Python");
//  Udp.endPacket(); // mark the end of the OSC Packet
//  delay(5000);
  

}//end setup loop

void loop(){
  //Serial.print(micros());
  ArduinoOTA.handle();
  //OSCMsgReceive();
//
  /* Get a new normalized sensor event */
  sensors_event_t accel;
  sensors_event_t gyro;
  sensors_event_t temp;
  //Serial.print(" "); Serial.println(micros());

  lsm6dsox.getEvent(&accel, &gyro, &temp);

  //Serial.println(millis());
  //Serial.println(lsm6dsox.rawAccX);
  if (encoder_count>tour-1){encoder_count=encoder_count-tour;}   
  if (encoder_count<0){encoder_count=tour+encoder_count;}
  //Serial.println(encoder_count);

  ////READ SPEED FROM SERVER
  char buffer4[20];
  memset(buffer4, 0, 20);     
  Udp.parsePacket(); 
  if(Udp.read(buffer4, 20) > 0){
    Serial.println("Message received");

    MatchState ms;
    ms.Target(buffer4);      
    Serial.println(buffer4);


    //const char * udpAddress = "192.168.0.255"; //broadcasting address= the program will read from this address
    //const int localPort = 6808;//4210;
    //const int outPort = 6807;
    
    char resultIP=ms.Match ("(IP)(%d+.%d+.%d+.%d+)",0);
    //Serial.println(resultIP);
    if (resultIP == REGEXP_MATCHED){
        char captureBufIP [20];
        udpAddress=ms.GetCapture (captureBufIP,1);
        Serial.print("Telemetry com IP changed to ");Serial.println(udpAddress);
    }  

    
    char resultPoke=ms.Match ("(Po)",0);
    //Serial.println(resultPoke);
    if (resultPoke == REGEXP_MATCHED){
        Serial.println("Poke");
        Poke=1; 
    }  

    char resultStiff=ms.Match ("(Stiff)",0);
      if (resultStiff == REGEXP_MATCHED){
        Serial.println("Motor state ON");
        Motor.State=1; 
        encoder_count_prev=encoder_count;          
        } 
    
    char resultSoft=ms.Match ("(Soft)",0);
      if (resultSoft == REGEXP_MATCHED){
        Serial.println("Motor state OFF");
        Motor.State=0; 
    } 

    char resultSpr=ms.Match ("(Spr)(%d+)(i)(%d+)(;)",0);
      if (resultSpr == REGEXP_MATCHED){ 
        char captureBufSpr [10];     
        k=atoi(ms.GetCapture (captureBufSpr,1)); 
        theta_0=atoi(ms.GetCapture (captureBufSpr,3));  
        Motor.State=2; 
        Serial.println("Spring mode");
      } 
    
    char resultSleep=ms.Match ("(Sl)",0);
      if (resultSleep == REGEXP_MATCHED){
        Serial.println("Going to sleep now");
        ledcWrite(MotChannel2,0);
        ledcWrite(MotChannel1,0);
        ///turn off RGB LED power to save battery life
        tp.DotStar_SetPower(true);
        tp.DotStar_SetPixelColor(30,0,0);
        tp.DotStar_Show();
        delay(2000);
        tp.DotStar_SetPower(false);
        esp_deep_sleep_start();
        delay(1000);  
      }  

    char resultSp=ms.Match ("(S)(%d+)(;)",0);
      if (resultSp == REGEXP_MATCHED){
        char captureBufSp [8];
        //Motor.Speed=atoi(ms.GetCapture (captureBufSp,1)); 
        Serial.print("pid controller PWM limit= ");Serial.println(atoi(ms.GetCapture (captureBufSp,1)));
        pidcontroller.limit( atoi(ms.GetCapture (captureBufSp,1))*(-1), atoi(ms.GetCapture (captureBufSp,1))); // Limit the PID output between -Motor.Speed to Motor.Speed, this is important to get rid of integral windup!
        pidcontroller_speed.limit( atoi(ms.GetCapture (captureBufSp,1))*(-1), atoi(ms.GetCapture (captureBufSp,1)));
        }

  //       char resultPW=ms.Match ("(PW)(%-?%+?%d+)(;)",0);
  //        if (resultPW == REGEXP_MATCHED){
  //          char captureBufPW [8];
  //          Motor.PWM=atoi(ms.GetCapture (captureBufPW,1)); 
  //          Serial.println("Motor.PWM=");Serial.println(Motor.PWM);
  //          pidcontroller.limit( Motor.Speed*(-1), Motor.Speed); // Limit the PID output between -Motor.Speed to Motor.Speed, this is important to get rid of integral windup!
  //        }
        
      char resultA=ms.Match ("(A)(%d+)(;)",0);
      if (resultA == REGEXP_MATCHED){
        char captureBufA [8];
        encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count;
        if (encoder_Shift<(-1)*tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count+tour;}    
        if (encoder_Shift>tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count-tour;}    
        Motor.Angle_target=atoi(ms.GetCapture (captureBufA,1));  
        //Serial.print("Motor.Angle_target=");Serial.println(Motor.Angle_target);  
        Serial.print("Angle target= ");Serial.print(Motor.Angle_target);
        Serial.print("encoder= ");Serial.println(encoder_count); //Serial.print(" shift = ");Serial.println(encoder_Shift);
        //encoder_count_prev=atoi(ms.GetCapture (captureBufA,1));   
        encoder_count_prev=encoder_count;  
        Motor.Ashift=encoder_Shift;   
        }

      char resultM=ms.Match ("(M)(%+?%-?%d+)(;)",0);
      if (resultM == REGEXP_MATCHED){
        char captureBufM [8];
        //ms.GetCapture (captureBufM,1);
        //encoder_Shift=encoder_count_prev+atoi(ms.GetCapture(captureBufM,1));
        encoder_Shift=atoi(ms.GetCapture(captureBufM,1));
        //Serial.println(captureBufM);
        // if (captureBufM[0]=='+'){Motor.Minus_State=false;Motor.Plus_State=true;Serial.println("Move +");}  
        // if (captureBufM[0]=='-'){Motor.Minus_State=true;Motor.Plus_State=false;Serial.println("Move -");} 
        Motor.Angle_target=(encoder_count_prev+atoi(ms.GetCapture(captureBufM,1)))%tour; 
        if (Motor.Angle_target<0){Motor.Angle_target=tour+encoder_count_prev;}    
        Serial.print('Angle = ');Serial.print(encoder_count);Serial.print(' Angle target= ');Serial.print(Motor.Angle_target);
        Serial.print(" encoder shift= ");Serial.println(encoder_Shift);
        encoder_count_prev=encoder_count;
        Motor.Ashift=encoder_Shift;
        }

      // char resultPot=ms.Match ("(P)(%d+)(;)",0);
      // if (resultPot == REGEXP_MATCHED){
      //   char captureBufPot [8];
      //   k=atoi(ms.GetCapture (captureBufPot,1));
      //   Serial.print("k= ");Serial.print(k);Serial.print("|| theta_0= ");;Serial.println(theta_0);
      //   if (captureBufPot[0]=='+'){Motor.Minus_State=false;Motor.Plus_State=true;Serial.println("Move +");}  
      //   if (captureBufPot[0]=='-'){Motor.Minus_State=true;Motor.Plus_State=false;Serial.println("Move -");}
      //   encoder_count_prev=encoder_count;          
      //   }
    }
      
 if (Poke){ 
    CountPoke=CountPoke+1;
    if (CountPoke <= 4000){
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(0,0,100);
      tp.DotStar_Show();  
      } else {tp.DotStar_SetPower(false);CountPoke=0;Poke=0;} 
    } 
 
  unsigned long currentMillis1 = millis();
  if (currentMillis1 - previousMillis1 <= 1000){   //1/this value=frequency at which value is send to broadcast
    previousMillis1 = currentMillis1;    // Save timestamp
    //Serial.println("POKE");
  tp.DotStar_SetPower(true);
  tp.DotStar_SetPixelColor(0,0,100);
  tp.DotStar_Show();  
  }else{tp.DotStar_SetPower(false);Poke=0;} 
 
 if (Motor.State==0){ // "soft" mode
    MotorOFF();
    encoder_count_prev=encoder_count;
    Motor.Angle_target=encoder_count_prev;
  }  

 if (Motor.State==1){  //"stiff" mode
       
  //   if (Motor.Plus_State || Motor.Minus_State){  
  //     if (Motor.Plus_State){
  //       //pidcontroller_speed.setpoint(Motor.Speed_target);
  //       pidcontroller_speed.setpoint(5);
  //       Serial.println("+ Pushed");
  //       //CONTROL_SPEED(pidcontroller_speed, Motor.PWM, 5, encoder_count, encoder_count_prev);       
  //       }      
        
                      
  //     if (Motor.Minus_State){
  //       pidcontroller_speed.setpoint(-5);
  //       //pidcontroller_speed.setpoint(-1*Motor.Speed_target);
  //       Serial.println("- Pushed");
  //       //CONTROL_SPEED(pidcontroller_speed, Motor.PWM, -5, encoder_count, encoder_count_prev);
  //       }

          
  //     if (test<30){  
  //     unsigned long currentMillis2 = millis();
  //       if (currentMillis2 - previousMillis2 >= 3){   //PID computed value updated every 10ms
  //         previousMillis2 = currentMillis2;    // Save timestamp                  
  //         //Motor.Speed=encoder_count-encoder_count_prev;
  //         //CONTROL_SPEED(pidcontroller_speed, Motor.Speed); 
  //         //Motor.Speed=encoder_count-encoder_count_prev;
  //         Motor.PWM=pidcontroller_speed.compute(encoder_count_prev-encoder_count);
  //         if (Motor.PWM > 0) {// if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
  //           motor_ccw(Motor.PWM);}
  //         else{ // else we move it in a counter clockwise direction
  //           motor_cw(abs(Motor.PWM));}                   
  //         //CONTROL_SPEED(pidcontroller_speed, Motor.Speed);          
  //         Serial.print(encoder_count); Serial.print(' '); Serial.print(encoder_count_prev);// Serial.print(' ');Serial.println(Motor.Speed);
  //         Serial.print(' '); Serial.print(Motor.PWM);Serial.print(" ");Serial.println(test);
  //         test=test+1; 
  //         //Serial.println(' ');//encoder_count_prev=encoder_count; 
  //         }
  //       } else {
  //       test=0;
  //       Motor.Plus_State=false;
  //       Motor.Minus_State=false;
  //       encoder_count_prev=encoder_count; 
  //         }    
            
  // //              unsigned long currentMillis3 = millis();
  // //              if (currentMillis3 - previousMillis3 >= 1000){   //PID computed value updated every 3ms
  // //                  previousMillis3 = currentMillis3;    // Save timestamp   
  // //                  //test=test+1;  
  // //                  pidcontroller_speed.setpoint(0);
  // //                  Motor.Speed=encoder_count-encoder_count_prev;  
  // //                  Motor.PWM=PID.compute(Motor.Speed);
  // //
  // //                  if (Motor.PWM > 0) {// if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
  // //                     motor_ccw(Motor.PWM);}
  // //                  else{ // else we move it in a counter clockwise direction
  // //                     motor_cw(abs(Motor.PWM));}         
  // //                  //CONTROL_SPEED(pidcontroller_speed, Motor.Speed);
  // //                  encoder_count_prev=encoder_count;
  // //                  Motor.Plus_State=false;
  // //                  Motor.Minus_State=false;         
  // //                 }
                                  
  // //           else{
  // //                  pidcontroller_speed.setpoint(0);
  // //                  Motor.Plus_State=false;
  // //                  Motor.Minus_State=false;
  // //                  //Serial.println("No motor push");
  // //                  //test=0;
  // //                  }
  // //                   
  //     } else {
  //         unsigned long currentMillis4 = millis();
  //         if (currentMillis4 - previousMillis4 >= 3){   //PID computed value updated every 3ms
  //           previousMillis4 = currentMillis4;    // Save timestamp                      
  //           pidcontroller.setpoint(encoder_count_prev); // The "goal" the PID controller tries to "reach",
  //           Motor.PWM = pidcontroller.compute(encoder_count);  //Let the PID compute the value, returns the calculated optimal output                     
  //           //Serial.print("No push, angle fixed to "); Serial.println(encoder_count);
  //           if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
  //             motor_ccw(Motor.PWM);}
  //           else{ // else we move it in a counter clockwise direction
  //             motor_cw(abs(Motor.PWM));}
  //             //Motor.Plus_State=false;
  //             //Motor.Minus_State=false;      
  //          }
  //       } 

  if (tour-Motor.Angle_target>round(tour/2)){Motor.Angle_target=tour+Motor.Angle_target;}
  if (Motor.Angle_target-encoder_count>round(tour/2)){encoder_count=tour+encoder_count;}
  
    unsigned long currentMillis4 = millis();
    if (currentMillis4 - previousMillis4 >= 2){   //PID computed value updated every 3ms
      previousMillis4 = currentMillis4;    // Save timestamp                      

      // encoder_count_2=encoder_count;
      // if (Motor.Angle_target-encoder_count>round(tour/2)){encoder_count_2=tour+encoder_count;}//else{encoder_count_2=encoder_count;}
      // if (Motor.Angle_target-encoder_count<(-1)*round(tour/2)){encoder_count_2=encoder_count-tour;}//else{encoder_count_2=encoder_count;}
      // //else {encoder_count_2=encoder_count;}
      
        
      pidcontroller.setpoint(Motor.Angle_target); // The "goal" the PID controller tries to "reach", 
      //Motor.PWM = pidcontroller.compute(encoder_count);

      // if (Motor.Angle_target-encoder_count>tour/2){
      //   pidcontroller.setpoint(Motor.Angle_target+tour);
      //   //Motor.PWM = pidcontroller.compute(tour-encoder_count); 
      //   //Serial.println(Motor.Angle_target-encoder_count);
      //   //Serial.print(tour/2);
      //   //Serial.print(" shift 1 = ");Serial.println(tour-encoder_count); 
      // } 
      
      // if (Motor.Angle_target-encoder_count<(-1)*tour/2){
      //   pidcontroller.setpoint(Motor.Angle_target+tour);
      //   //Motor.PWM = pidcontroller.compute(encoder_count+tour); 
      //   //Serial.print(Motor.Angle_target-encoder_count);
      //   //Serial.print((-1)*tour/2);
      //   //Serial.print(" shift 2 = ");Serial.println(encoder_count+tour); Serial.println(round((-1)*tour/2));
      //   } //else {Motor.PWM = pidcontroller.compute(encoder_count);}
      
      Motor.PWM = pidcontroller.compute(encoder_count); 
      //motor(Motor.PWM);
     if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM);}
     else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM));}
      if (encoder_count>tour){encoder_count=encoder_count-tour;}


      // encoder_count_target=Motor.Angle_target;   
      
      // while (Motor.Ashift!=0){
      //   Motor.Ashift=(encoder_count_prev+encoder_Shift-encoder_count)%tour; 
      //   if (Motor.Angle_target-encoder_count>round(tour/2)){encoder_count_target=tour-Motor.Angle_target;}//else{encoder_count_2=encoder_count;}
      //   if (Motor.Angle_target-encoder_count<(-1)*round(tour/2)){encoder_count_target=tour+Motor.Angle_target;}//else{encoder_count_2=encoder_count;}
      // //else {encoder_count_2=encoder_count;}
      // }

      // Serial.print("Shift: "); Serial.println(Motor.Ashift);Serial.print("Target: "); Serial.println(encoder_count_target); Serial.print("PID input: ");Serial.println(encoder_count);
      // pidcontroller.setpoint(encoder_count_target); // The "goal" the PID controller tries to "reach",   
      // Motor.PWM = pidcontroller.compute(encoder_count);  //L 
      // motor(Motor.PWM);

      // Motor.Ashift=(encoder_count_prev+encoder_Shift-encoder_count)%tour; 
      // if  (Motor.Ashift!=0){
      //   Serial.print("Shift: "); Serial.println(Motor.Ashift);Serial.print("Target: "); Serial.println(encoder_count_target); Serial.print("PID input: ");Serial.println(encoder_count);
      //   pidcontroller.setpoint(encoder_count_target); // The "goal" the PID controller tries to "reach",   
      //   Motor.PWM = pidcontroller.compute(encoder_count);  //L 
      //   motor(Motor.PWM);
      // } else {
      //   pidcontroller.setpoint(Motor.Angle_target); // The "goal" the PID controller tries to "reach",   
      //   Motor.PWM = pidcontroller.compute(encoder_count);  //L 
      //   motor(Motor.PWM);
      // }

      // //ControlCircPos(tour,encoder_count_prev);
      // //if (encoder_count-Motor.Angle_target<0){encoder_count_prev=encoder_count%tour;}
      // //Motor.Angle_target
      // //encoder_count_prev
      // ///encoder_Shift=tour-Motor.Angle_target-encoder_count_prev;
      // pidcontroller.setpoint(0); // The "goal" the PID controller tries to "reach",        
      // //Motor.Ashift=(encoder_count_prev+encoder_Shift-encoder_count)%tour;
      // Motor.Ashift=(encoder_count_prev+encoder_Shift-encoder_count)%tour;
      // Motor.PWM = pidcontroller.compute(Motor.Ashift);

      // //Serial.println(Motor.Ashift);
      
      // if  (Motor.Ashift==0){
      //   //encoder_count_prev=encoder_count_prev+encoder_Shift;
      //   //if (encoder_count_prev<0){encoder_count_prev=tour+encoder_count_prev;}   
      //   //if (encoder_count_prev>tour){encoder_count_prev=encoder_count_prev-tour;}    
      //   //Serial.print("updated target: "); Serial.println(encoder_count_prev);
      //   encoder_count_prev=encoder_count_prev+encoder_Shift;
      //   encoder_Shift=0;    
      //   //Serial.print("updated target: "); Serial.println(encoder_count_prev);
      // }

    // if (encoder_Shift<0){Motor.Ashift=encoder_count-Motor.Angle_target;}

    // if (Motor.Angle_target<encoder_count){encoder_Shift}



    // pidcontroller.setpoint(Motor.Angle_target); // The "goal" the PID controller tries to "reach",
    // Motor.PWM = pidcontroller.compute(Motor.Ashift);  //Let the PID compute the value, returns the calculated optimal output                     
    // motor(Motor.PWM);
  
    // //Serial.print("No push, angle fixed to "); Serial.println(encoder_count);
    // if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
    //   motor_ccw(Motor.PWM);}
    // else{ // else we move it in a counter clockwise direction
    //   motor_cw(abs(Motor.PWM));}    
      }



    
  } 
  

  if (Motor.State==2){ // "spring" mode
      Serial.println("Inside mode spring");
      Motor.PWM=k*(encoder_count-theta_0);
      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
          motor_ccw(Motor.PWM);}
      else{ // else we move it in a counter clockwise direction
          motor_cw(abs(Motor.PWM));}
  }
      

  ////////////////////////Data format and send
  unsigned long currentMillis5 = millis();
  if (currentMillis5 - previousMillis5 >= 4){   //1/this value=frequency at which messages are sent outward
    previousMillis5 = currentMillis5;    // Save timestamp   

    // Motor.Angle=map(encoder_count,round(tour/2),tour+round(tour/2),0,1023);
    // Motor.Angle=(Motor.Angle+512)%1023;
    Motor.Angle=encoder_count;
    
    //ThetaG=atan2((double)accel.acceleration.y,(double)accel.acceleration.x)-(M_PI/4);
    //if (ThetaG<=-M_PI){ThetaG=M_PI/4-abs(ThetaG+M_PI)+(3*M_PI/4);} //rotation of pi/4 to take the plug up as 0 reference
    //Serial.println(ThetaG);
  
    // create JSON object 
    // Declare a buffer to hold the result
    char output[192];// recomended size. can be decreased down to 144 max. https://arduinojson.org/v6/assistant/
    StaticJsonDocument<192> motion;

    // Compute the length of the minified JSON document
    //      int len1=measureJson(motion);
    //      Serial.print("JSON document size:");Serial.println(len1);
    motion["d"] = Motor.Address;
    motion["t"] = millis();
    motion["A"] = Motor.Angle;    
    motion["x"] = accel.acceleration.x;
    motion["y"] = accel.acceleration.y;
    motion["z"] = accel.acceleration.z;
    motion["u"] = gyro.gyro.x;
    motion["v"] = gyro.gyro.y;
    motion["w"] = gyro.gyro.z;

    //Serial.println(lsm6dsox.rawAccX);
    
    serializeJson(motion,output);
    //serializeJson(motion,Serial);
    //Serial.println();
    //Serial.print(" ");Serial.println(micros());
    
    //char buffer1[128];
    //memset(buffer1, 0, 6);   
    Udp.beginPacket(udpAddress, outPort);   
    //itoa(Motor.Angle, buffer1,10);
    //Udp.print("A");
    Udp.print(output);
    Udp.endPacket();
    // Serial.print(" ");Serial.println(micros());
    //Serial.println(Motor.Angle);

    }///loop current millis
//
//    unsigned long currentMillis6 = millis();
//    if (currentMillis6 - previousMillis6 >= 10000){   //PID computed value updated every 3ms
//        previousMillis6 = currentMillis6;    // Save timestamp   
//    
//        char bufBat[8];
//        memset(bufBat, 0, 8);
//        bufBat.add(((tp.GetBatteryVoltage()-3.5)/0.70)*100);
//        Udp.beginPacket(udpAddress, outPort);   
//        Udp.print(bufBat);
//        Udp.endPacket();   
//    }
//  //Serial.print(" ");Serial.println(millis());

}   //end void loop