/*Granulobot UDP Firmware V13 
 * Encoder position measurement and conversion in angle and angular velocity
 * Magnet's magnetic field measurement
 * accel + gyr measurement
 * PWM Control of N20 geared motors
 * 2 ways UDP wifi communication with broadcasting address
 * PID on position encoder  https://github.com/DonnyCraft1/PIDArduino
 * https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller
 *  OTA wireless firmware upload: https://randomnerdtutorials.com/esp32-over-the-air-ota-programming/

*      autoselect particule address from database defined in header {IP address number(last digits),paticule adress number}
* New on V13:
*      ??????????
*
*components controlled by the firmware:
*
*accel+gyro: LSM6DSOX 
*magnetic sensor: Tlv493d (+-150mT)
*magnetic encoder: Pololu
*Motor driver: DRV8833
*Microcontroller: ESP32
*StepUp motor: TPS61178 (with Enable Pin)
*
*OpenStageControl ressources:
*https://openstagecontrol.ammd.net/docs/custom-module/custom-module/
*
*by Baudouin Saintyves
*October 28th 2021
*
* Data generated by the robot:
* "{"A":1,"t":97768,"d":5,"x":0.052642,"y":-0.095713,"z":9.818948,"u":0.001222,"v":0.00733,"w":-0.006109}"
*
* for .bin versioning, see https://stackoverflow.com/questions/56923895/auto-increment-build-number-using-platformio
*/

///////Include Local///////////////
//#include "Wifi_Home.h"
#include "Wifi_NET.h"
//#include "Wifi_TP_1.h"
//#include "Wifi_Marc.h"

#include "Granulobot_pin_v1_2.h"
//#include "Granulobot_pin_v1_1.h"
//////////////////////////////////

///////MAC ADRESS DATABASE
////add here new two last characters of Mac Address. //Particule number 
// char *ADDRESS_DATA_BASE[] = {  //
//   "FC",//1
//   "08",//2
//   "20",//3
//   "78",//4
//   "38",//5
//   "4C",//6
//   "E8",//7
//   "60",//8
//   "54",//9
//   "88",//10
//   "24",//11
//   "B8",//12
//   "B4",//13
//   "A4",//14
//   "84",//15
//   //add new particule here
//   "00"
// };
//////////////////////////////
char *ADDRESS_DATA_BASE[] = {  //
  "4D:94",//1
  "3E:A8",//2
  "4D:88",//3
  "4D:A4",//4
  "3E:B8",//5
  "4D:B4",//6
  "4D:A8",//7
  "4D:D4",//8
  "4E:24",//9
  "4D:84",//10
  //add new particule here
  "00:00"
};

/////MOTOR PARAMETERS//////////
//choose here the motor's gear ratio
 const int ratio=210;

//choose here the motor's PID parameters
#define __Kp 260//260 // Proportional constant
#define __Ki 2.7 // Integral Constant
#define __Kd 2000//2000 // Derivative Constant

//choose here motor's PWM frequency
#define FREQ 100
////////////////////////////////////
////////////////////////////////////

////////////////////////////////////
/////EXTERNAL LIBRARIES//////////////////////

 //Arduino
#include <Arduino.h>

  //Wifi
#include <WiFi.h>
#include <WiFiUdp.h>
#include <ESPmDNS.h>
#include <ArduinoOTA.h> //library for Over The Air programming

  //sensors
#include <Adafruit_Sensor.h>
#include <Adafruit_LSM6DSOX.h>//accel+gyro
#include <Adafruit_LSM6DS.h>//accel+gyro
#include <Tlv493d.h>//magnetic field sensor

  //packet format and parsing for serial com
#include <Regexp.h>
#include <ArduinoJson.h> // tuto https://arduinojson.org/v6/doc/serialization/

  //TinyPico Helper Library
#include <TinyPICO.h>

// //OSC library     https://github.com/CNMAT/OSC
#include <OSCMessage.h> 
#include <OSCBundle.h>
#include <OSCData.h>

  //PID library
#include <PIDController.h> // https://github.com/DonnyCraft1/PIDArduino

  
////particule address number
//int ADDRESS_NUM;

//counter for poke function
int CountPoke=0;

 //Timers
unsigned long previousMillis1 = 0; // store previous millis readout (for PID)
unsigned long previousMillis2 = 0; // store previous millis readout (to send motor.angle)
unsigned long previousMillis3 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis4 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis5 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis6 = 0; // store previous millis readout (to send Bat level)

//Encoder
volatile int encoder_count=0;
int encoder_count_prev=0;
int encoder_start;
//int prev_count=0;
volatile bool CW;
volatile bool Soft;
const int tour=ratio*12;
const int Res_speed=4;//in ms
int prev_pos=0;
long int speed_tick;
float speed_rad;
int angle_tick=0;
float angle_rad=0;
int speed_target=0;
int direct=0;
int previous=0;
int direct_rec=0;
int k=0;//spring potential
int theta_0=0;
int theta_eq=0;
int theta_star=0;
int bias=0;
int previous_encoder_count=0;
int dtheta=0;
bool state=false;
int dt=0;

unsigned int angle_target = 0; // stores the incoming serial value. Max value is 65535
char incomingByte; // parses and stores each individual character one by one
//int motor_pwm_value = 255; // after PID computation data is stored in this variable.


struct Button {
  const uint8_t PIN;
  //uint32_t encoder_count;
  bool detect;
};

Button MA = {ENCODER_A, false};//Encoder OUT A
Button MB = {ENCODER_B, false};//Encoder OUT B


//Motor control

//global variables
bool MoveStop=false;
// setting PWM properties
const int freq = FREQ;
const int MotChannel1 = 1;
const int MotChannel2 = 2;
const int resolution = 8;

//for PID
//int motor_pwm_value = 0; // after PID computation data is stored in this variable.
unsigned int integerValue = 0;

bool Poke=false;

//for OSC Com
typedef struct Message {
  int Address;
  int Mode;
  int Torque;
  int Max_Torque;
  int Speed;
  int Speed_target;
  int Vshift;
  int Ashift;
  int State;
  //int Displacement;
  int Angle;
  int Angle_target;
  bool Direction;//true=CW or false=CCW
  int PWM; // after PID computation data is stored in this variable.
  bool Minus_State;
  bool Plus_State;
} Message;

int P=0;
int angle_interval;
int test_prev;
int test=0;
int encoder_Shift=0;
int encoder_count_2=0;
int encoder_count_target=0;

float ThetaG;

Message Motor;


///deep sleep
//#define BUTTON_PIN_BITMASK 0x200000000 // 2^33 in hex / for deep sleep on pin 33 with ext1
RTC_DATA_ATTR int bootCount = 0; // for deep sleep
/////////////////////////////////////

//INITIALISE
 //Initialise sensors
    // LSM6DSOX Object
Adafruit_LSM6DSOX lsm6dsox;
    // Tlv493d Object
Tlv493d Tlv493dMagnetic3DSensor = Tlv493d();
    //create PID object
PIDController pidcontroller;
PIDController pidcontroller_speed;

//create UDP instance
WiFiUDP Udp;
OSCErrorCode error;

// Initialise TinyPICO library
TinyPICO tp = TinyPICO();

//const int capacity=JSON_ARRAY_SIZE(3)+JSON_OBJECT_SIZE(1)+2*JSON_OBJECT_SIZE(3);
const int capacity = JSON_OBJECT_SIZE(9);
StaticJsonDocument<capacity> motion;

////////////////////////////////////
/////FUNCTIONS//////////////////////
void MotorOFF(){
  ledcWrite(MotChannel1, 0);
  ledcWrite(MotChannel2, 0);
  }


void motor(int power) {
  if (abs(power) > 20) {
    if (power > 0) {
      //Serial.println("Motor cw");
      ledcWrite(MotChannel1, abs(power));
      ledcWrite(MotChannel2, 0);     
      } 
    else{
      //Serial.println("Motor ccw");
      ledcWrite(MotChannel1, 0);
      ledcWrite(MotChannel2, power);
      }
  } 
  else{
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}

void motor_cw(int power) {
  if (power > 20) {
    //Serial.println("Motor cw");
    ledcWrite(MotChannel1, power);
    ledcWrite(MotChannel2, 0);
  }
  else {
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}
void motor_ccw(int power) {
  if (power > 20) {
    //Serial.println("Motor ccw");
    ledcWrite(MotChannel2, power);
    ledcWrite(MotChannel1, 0);
  }
  else {
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}


void CONTROL_SPEED(PIDController PID, int Speed){     
    //Serial.println("control speed");
    int PWM=PID.compute(Speed);
    Serial.print("control speed, PWM= ");Serial.println(PWM);
    if (PWM > 0) // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(PWM);
    else // else we move it in a counter clockwise direction
      motor_cw(abs(PWM));  
    } 


void displaySensorDetailsISM(void) {
  Serial.print("Accelerometer range set to: ");
  switch (lsm6dsox.getAccelRange()) {
  case LSM6DS_ACCEL_RANGE_2_G:
    Serial.println("+-2G");
    break;
  case LSM6DS_ACCEL_RANGE_4_G:
    Serial.println("+-4G");
    break;
  case LSM6DS_ACCEL_RANGE_8_G:
    Serial.println("+-8G");
    break;
  case LSM6DS_ACCEL_RANGE_16_G:
    Serial.println("+-16G");
    break;
  }
  
  Serial.print("Gyro range set to: ");
  switch (lsm6dsox.getGyroRange()) {
  case LSM6DS_GYRO_RANGE_125_DPS:
    Serial.println("125 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_250_DPS:
    Serial.println("250 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_500_DPS:
    Serial.println("500 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_1000_DPS:
    Serial.println("1000 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_2000_DPS:
    Serial.println("2000 degrees/s");
    break;
  case ISM330DHCX_GYRO_RANGE_4000_DPS:
    Serial.println("4000 degrees/s");
    break;
  }

  Serial.print("Accelerometer data rate set to: ");
  switch (lsm6dsox.getAccelDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }

  Serial.print("Gyro data rate set to: ");
  switch (lsm6dsox.getGyroDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }
}
/*
Method to print the reason by which ESP32
has been awaken from sleep
*/
void print_wakeup_reason(){
  esp_sleep_wakeup_cause_t wakeup_reason;

  wakeup_reason = esp_sleep_get_wakeup_cause();

  switch(wakeup_reason)
  {
    case ESP_SLEEP_WAKEUP_EXT0 : Serial.println("Wakeup caused by external signal using RTC_IO"); break;
    case ESP_SLEEP_WAKEUP_EXT1 : Serial.println("Wakeup caused by external signal using RTC_CNTL"); break;
    case ESP_SLEEP_WAKEUP_TIMER : Serial.println("Wakeup caused by timer"); break;
    case ESP_SLEEP_WAKEUP_TOUCHPAD : Serial.println("Wakeup caused by touchpad"); break;
    case ESP_SLEEP_WAKEUP_ULP : Serial.println("Wakeup caused by ULP program"); break;
    default : Serial.printf("Wakeup was not caused by deep sleep: %d\n",wakeup_reason); break;
  }
}


/////////////////////////////////////
//attach interrupt functions for encoder
void IRAM_ATTR isr_A() {
if (digitalRead(MA.PIN) == HIGH){
    if (digitalRead(MB.PIN) == HIGH){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
else{ if (digitalRead(MB.PIN) == LOW){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }       
MA.detect = true;
}


void IRAM_ATTR isr_B() {
if (digitalRead(MB.PIN) == HIGH){
    if (digitalRead(MA.PIN) == LOW){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
else{
    if (digitalRead(MA.PIN) == HIGH){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
MB.detect = true;
}
///////////////////////////////////////////////
////////////////////////////////////////////////

void setup(){

  Wire.setClock(400000); //test 
  
  // log_d("Total heap: %d", ESP.getHeapSize());//core debug level to "verbose"
  // log_d("Free heap: %d", ESP.getFreeHeap());
  // log_d("Total PSRAM: %d", ESP.getPsramSize());
  // log_d("Free PSRAM: %d", ESP.getFreePsram());
  
  Serial.begin(115200);
  Serial.println("RESET");
  Serial.println("Firmware Granulobot UDP V13");


//WIFI UDP SETUP

  //Connect to the WiFi network
  WiFi.begin(ssid, pwd);
  Serial.println("");

  Serial.print("ESP Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
  // Wait for connection
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  //This initializes udp and transfer buffer
  Udp.begin(localPort);
 
  ///////


//////ARDUINO OTA 
ArduinoOTA
    .onStart([]() {
      String type;
      if (ArduinoOTA.getCommand() == U_FLASH)
        type = "sketch";
      else // U_SPIFFS
        type = "filesystem";

      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
      Serial.println("Start updating " + type);
    })
    .onEnd([]() {
      Serial.println("\nEnd");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      Serial.printf("Error[%u]: ", error);
      if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
      else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
      else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
      else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
      else if (error == OTA_END_ERROR) Serial.println("End Failed");
    });

  ArduinoOTA.begin();
  /////////////////////////////////////
//  
////  //particule address selection  
std::string EndMAC{WiFi.macAddress()[12],WiFi.macAddress()[13],WiFi.macAddress()[14],WiFi.macAddress()[15],WiFi.macAddress()[16]};
  int index=0;
  for (int i=0; i<(sizeof(ADDRESS_DATA_BASE) / sizeof(ADDRESS_DATA_BASE[0])); i++) {
     if (EndMAC == ADDRESS_DATA_BASE[i]) {
       index = i;
       // Serial.print(local[5],HEX);
        Serial.print((sizeof(ADDRESS_DATA_BASE) / sizeof(ADDRESS_DATA_BASE[0])));Serial.print(" adresses to choose from, index: ");Serial.println(index);    
       break;
     }
     else{Serial.println("No adress found ");index=-1;}
  }
  IPAddress local=WiFi.localIP();

//Serial.print("Two last char of MAC address: ");Serial.println(EndMAC);

// 
 //intitialisation of Motor structure
  //Motor.Address=ADDRESS_DATA_BASE[index][1];//ADDRESS
  Motor.Address=index+1;//ADDRESS
  Motor.Mode=0;
  Motor.Speed=0;
  Motor.Speed_target=5;
  Motor.Torque=0;
  Motor.Max_Torque=255;
  Motor.Angle=0;
  Motor.Angle_target=0;
  Motor.Direction=true;
  Motor.State=0;
  Motor.PWM=0;
  Motor.Vshift=0;
  Motor.Minus_State=false;
  Motor.Plus_State=false;
 Serial.print("Motor address:");Serial.println(Motor.Address);
  
/////deep sleep mode setup
++bootCount;
  Serial.println("Boot number: " + String(bootCount));

  //Print the wakeup reason for ESP32
  print_wakeup_reason();

  /*
  First we configure the wake up source
  We set our ESP32 to wake up for an external trigger.
  There are two types for ESP32, ext0 and ext1 .
  ext0 uses RTC_IO to wakeup thus requires RTC peripherals
  to be on while ext1 uses RTC Controller so doesnt need
  peripherals to be powered on.
  Note that using internal pullups/pulldowns also requires
  RTC peripherals to be turned on.
  */
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_5,1); //1 = High, 0 = Low

  /////////

  tp.DotStar_SetPower(true);
  tp.DotStar_SetPixelColor(0,200,0);
  tp.DotStar_Show();
  delay(2000);
  ///turn off RGB LED power to save battery life
  tp.DotStar_SetPower(false);
  
  
  ////SETUP SENSORS
  //Tlv493d
  Tlv493dMagnetic3DSensor.begin();
  Serial.println("Tlv493d Found!");

    //LSM6DSOX

    lsm6dsox.setAccelRange(LSM6DS_ACCEL_RANGE_8_G);
    lsm6dsox.setGyroRange(LSM6DS_GYRO_RANGE_2000_DPS); 
    lsm6dsox.setAccelDataRate(LSM6DS_RATE_3_33K_HZ);
    lsm6dsox.setGyroDataRate(LSM6DS_RATE_3_33K_HZ);

  while (!Serial)
    delay(10); // will pause Zero, Leonardo, etc until serial console opens 

  Serial.println("Adafruit lsm6dsox test!");

  if(!lsm6dsox.begin_I2C(0x6A)){
    Serial.println("Failed first attempt");
    if(!lsm6dsox.begin_I2C(0x6B)){
      Serial.println("Failed to find lsm6dsox chip");
      while (1) delay(10);
    }
  }

  Serial.println("lsm6dsox Found!");

  delay(500);

    //Encoder
  pinMode(MA.PIN, INPUT);
  attachInterrupt(MA.PIN, isr_A, CHANGE);
  pinMode(MB.PIN, INPUT);
  attachInterrupt(MB.PIN, isr_B, CHANGE);
  Serial.print("ticks per tour=");Serial.println(tour);
  ////////


  //ENABLE BOOST
  pinMode(EN_BOOST, OUTPUT);
  digitalWrite(EN_BOOST, HIGH);// Start with Boost on.  

  //MOTOR SETUP
    //Initialize the motor driver switch pin.
  pinMode(MOT_SLP_PIN, OUTPUT);
  digitalWrite(MOT_SLP_PIN, HIGH);// Start with drivers on.
    //PWM setup 
  ledcSetup(MotChannel1, freq, resolution);
  ledcSetup(MotChannel2, freq, resolution);

  ledcAttachPin(MOT_A1_PIN, MotChannel1);
  ledcAttachPin(MOT_A2_PIN, MotChannel2);
  ///////
  
  //PID
  pidcontroller.begin(); // initialize the PID instance
  pidcontroller.tune(__Kp,__Ki,__Kd); // Tune the PID, arguments: kP, kI, kD
  pidcontroller.limit((-1)*Motor.Max_Torque, Motor.Max_Torque); // Limit the PID output between -255 to 255, this is important to get rid of integral windup!


  //PID speed
  pidcontroller_speed.begin(); // initialize the PID instance
  pidcontroller_speed.tune(__Kp,__Ki,__Kd); // Tune the PID, arguments: kP, kI, kD
  pidcontroller_speed.limit((-1)*Motor.Max_Torque, Motor.Max_Torque); // Limit the PID output between -255 to 255, this is important to get rid of integral windup!


//// Get a *rough* estimate of the current battery voltage
  // If the battery is not present, the charge IC will still report it's trying to charge at X voltage
  // so it will still show a voltage.
  Serial.print("Battery level: ");
  Serial.println(tp.GetBatteryVoltage());
  Serial.print("Battery charging in progress: ");
  Serial.println(tp.IsChargingBattery());  
  delay(2000);
  Serial.print("battery level= ");Serial.print(((tp.GetBatteryVoltage()-3.5)/0.70)*100);Serial.println("%");

}//end setup loop

void loop(){
  //Serial.print(micros());
  ArduinoOTA.handle();
  //OSCMsgReceive();
//
  /* Get a new normalized sensor event */
  sensors_event_t accel;
  sensors_event_t gyro;
  sensors_event_t temp;
  //Serial.print(" "); Serial.println(micros());

  lsm6dsox.getEvent(&accel, &gyro, &temp);

  //Serial.println(millis());
  //Serial.println(lsm6dsox.rawAccX);
  if (encoder_count>tour-1){encoder_count=encoder_count-tour;}   
  if (encoder_count<0){encoder_count=tour+encoder_count;}
  //Serial.println(encoder_count);

  ////READ SPEED FROM SERVER
  char buffer4[20];
  memset(buffer4, 0, 20);     
  Udp.parsePacket(); 
  if(Udp.read(buffer4, 20) > 0){
    Serial.println("Message received");

    MatchState ms;
    ms.Target(buffer4);      
    Serial.println(buffer4);
    
    char resultIP=ms.Match ("(IP)(%d+.%d+.%d+.%d+)",0);
    //Serial.println(resultIP);
    if (resultIP == REGEXP_MATCHED){
      char captureBufIP [20];
      udpAddress=ms.GetCapture (captureBufIP,1);
      Serial.print("Telemetry com IP changed to ");Serial.println(udpAddress);
    }  

    
    char resultPoke=ms.Match ("(Po)",0);
    //Serial.println(resultPoke);
    if (resultPoke == REGEXP_MATCHED){
      Serial.println("Poke");
      Poke=1; 
    }  

    char resultStiff=ms.Match ("(Stiff)",0);
      if (resultStiff == REGEXP_MATCHED){
        Serial.println("Motor state ON");
        Motor.State=1; 
        encoder_count_prev=encoder_count;          
      } 
    
    char resultSoft=ms.Match ("(Soft)",0);
      if (resultSoft == REGEXP_MATCHED){
        Serial.println("Motor state OFF");
        Motor.State=0; 
      } 

    char resultSpr=ms.Match ("(Spr)(%s)(%a)(%d+)(b)(%d+)(;)",0);// choose bias in the range 0-500|||choose k in the range 0-1000
      if (resultSpr == REGEXP_MATCHED){ 
        char captureBufSpr [15];     
        Motor.State=2;
        theta_eq=encoder_count; 
        theta_star=0;  
        test=0;
        bias=atoi(ms.GetCapture (captureBufSpr,5));
        Serial.println("Spring mode");
        Serial.print("Theta_eq=");Serial.println(theta_eq);
        Serial.print("bias= ");Serial.println(bias);
        Serial.print("max PWM=");Serial.println(Motor.Max_Torque);
        //Serial.print("buffer 2 =");Serial.println(ms.GetCapture (captureBufSpr,2));

        if (!strcmp(ms.GetCapture (captureBufSpr,2),"k")){
          k=atoi(ms.GetCapture (captureBufSpr,3)); 
          //theta_0=(Motor.Max_Torque-bias)*1000/k;
          theta_0=(Motor.Max_Torque)*1000/k;
          Serial.print("control k=");Serial.println(k);
          Serial.print("Theta_0=");Serial.println(theta_0);

        }
        
        if (!strcmp(ms.GetCapture (captureBufSpr,2),"t")){
          theta_0=atoi(ms.GetCapture (captureBufSpr,3)); 
          //k=(Motor.Max_Torque-bias)*1000/(theta_0);
          k=(Motor.Max_Torque)*1000/(theta_0);
          Serial.print("control Theta_0=");Serial.println(theta_0);
          Serial.print("k=");Serial.println(k);
          
        }

        //k=atoi(ms.GetCapture (captureBufSpr,1)); 
        //theta_0=atoi(ms.GetCapture (captureBufSpr,3));  


        
      } 
    
    char resultSleep=ms.Match ("(Sl)",0);
      if (resultSleep == REGEXP_MATCHED){
        Serial.println("Going to sleep now");
        ledcWrite(MotChannel2,0);
        ledcWrite(MotChannel1,0);
        ///turn off RGB LED power to save battery life
        tp.DotStar_SetPower(true);
        tp.DotStar_SetPixelColor(30,0,0);
        tp.DotStar_Show();
        delay(2000);
        tp.DotStar_SetPower(false);
        esp_deep_sleep_start();
        delay(1000);  
      }  

    char resultSp=ms.Match ("(S)(%d+)(;)",0);
      if (resultSp == REGEXP_MATCHED){
        char captureBufSp [8];
        //Motor.Speed=atoi(ms.GetCapture (captureBufSp,1)); 
        Motor.Max_Torque=atoi(ms.GetCapture (captureBufSp,1));
        Serial.print("pid controller PWM limit= ");Serial.println(atoi(ms.GetCapture (captureBufSp,1)));
        pidcontroller.limit(Motor.Max_Torque*(-1), Motor.Max_Torque); // Limit the PID output between -Motor.Speed to Motor.Speed, this is important to get rid of integral windup!
        pidcontroller_speed.limit(Motor.Max_Torque*(-1), Motor.Max_Torque);
      }

  //       char resultPW=ms.Match ("(PW)(%-?%+?%d+)(;)",0);
  //        if (resultPW == REGEXP_MATCHED){
  //          char captureBufPW [8];
  //          Motor.PWM=atoi(ms.GetCapture (captureBufPW,1)); 
  //          Serial.println("Motor.PWM=");Serial.println(Motor.PWM);
  //          pidcontroller.limit( Motor.Speed*(-1), Motor.Speed); // Limit the PID output between -Motor.Speed to Motor.Speed, this is important to get rid of integral windup!
  //        }
        
      char resultA=ms.Match ("(A)(%d+)(;)",0);
      if (resultA == REGEXP_MATCHED){
        char captureBufA [8];
        //encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count;
        //if (encoder_Shift<(-1)*tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count+tour;}    
        //if (encoder_Shift>tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count-tour;}    
        Motor.Angle_target=atoi(ms.GetCapture (captureBufA,1));  
        //Serial.print("Motor.Angle_target=");Serial.println(Motor.Angle_target);  
        Serial.print("Angle target= ");Serial.print(Motor.Angle_target);
        Serial.print("encoder= ");Serial.println(encoder_count); //Serial.print(" shift = ");Serial.println(encoder_Shift);
        //encoder_count_prev=atoi(ms.GetCapture (captureBufA,1));   
        encoder_count_prev=encoder_count;  
        //Motor.Ashift=encoder_Shift;   
      }

      char resultM=ms.Match ("(M)(%+?%-?%d+)(;)",0);
      if (resultM == REGEXP_MATCHED){
        char captureBufM [8];
        //ms.GetCapture (captureBufM,1);
        //encoder_Shift=encoder_count_prev+atoi(ms.GetCapture(captureBufM,1));
        //encoder_Shift=atoi(ms.GetCapture(captureBufM,1));
        //Serial.println(captureBufM);
        // if (captureBufM[0]=='+'){Motor.Minus_State=false;Motor.Plus_State=true;Serial.println("Move +");}  
        // if (captureBufM[0]=='-'){Motor.Minus_State=true;Motor.Plus_State=false;Serial.println("Move -");} 
        //Motor.Angle_target=(encoder_count_prev+atoi(ms.GetCapture(captureBufM,1)))%tour; 
        Motor.Angle_target=(encoder_count+atoi(ms.GetCapture(captureBufM,1)))%tour; 
        if (Motor.Angle_target<0){Motor.Angle_target=tour+Motor.Angle_target;}    
        Serial.print("Angle = ");Serial.print(encoder_count);Serial.print(" Angle target= ");Serial.print(Motor.Angle_target);
        Serial.print(" encoder shift= ");Serial.println(encoder_Shift);
        //encoder_count_prev=encoder_count;
        //Motor.Ashift=encoder_Shift;
      }
    }
      
 if (Poke){ 
    CountPoke=CountPoke+1;
    if (CountPoke <= 4000){
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(0,0,100);
      tp.DotStar_Show();  
      } else {tp.DotStar_SetPower(false);CountPoke=0;Poke=0;} 
    } 
 
  unsigned long currentMillis1 = millis();
  if (currentMillis1 - previousMillis1 <= 1000){   //1/this value=frequency at which value is send to broadcast
    previousMillis1 = currentMillis1;    // Save timestamp
    //Serial.println("POKE");
    tp.DotStar_SetPower(true);
    tp.DotStar_SetPixelColor(0,0,100);
    tp.DotStar_Show();  
  }else{tp.DotStar_SetPower(false);Poke=0;} 
 
 if (Motor.State==0){ // "soft" mode
    MotorOFF();
    encoder_count_prev=encoder_count;
    Motor.Angle_target=encoder_count_prev;
  }  

  // unsigned long currentMillis2 = millis();
  // if (currentMillis2 - previousMillis2 >= Res_speed){   //PID computed value updated every 3ms
  //   previousMillis2 = currentMillis2;    // S
  //   dtheta=encoder_count-previous_encoder_count;
  //   if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  //   else if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  //   else {Motor.Speed=dtheta;}
  //   //Motor.Speed=dtheta;
  //   previous_encoder_count=encoder_count;
  //   //Serial.print("Motor speed = ");Serial.println(Motor.Speed);
  // }
  
  unsigned long currentMillis2 = millis();
  dtheta=encoder_count-previous_encoder_count;
  if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  else if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  else {Motor.Speed=dtheta;}
  previous_encoder_count=encoder_count;
  dt=currentMillis2-previousMillis2;
  previousMillis2 = currentMillis2;


  if (Motor.State==1){  //"stiff" mode
       

    if (tour-Motor.Angle_target>round(tour/2)){Motor.Angle_target=tour+Motor.Angle_target;}
    if (Motor.Angle_target-encoder_count>round(tour/2)){encoder_count=tour+encoder_count;}
  
    unsigned long currentMillis4 = millis();
    if (currentMillis4 - previousMillis4 >= 2){   //PID computed value updated every 3ms
      previousMillis4 = currentMillis4;    // Save timestamp                      
      
      pidcontroller.setpoint(Motor.Angle_target); // The "goal" the PID controller tries to "reach", 
   
      Motor.PWM = pidcontroller.compute(encoder_count); 
      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM);}
      else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM));}
     
      //motor(Motor.PWM); //not working

      if (encoder_count>tour){encoder_count=encoder_count-tour;}
    }    
  } 

  if (Motor.State==2){ // "spring" mode
      //Serial.println("Inside mode spring");
      

      // dtheta=encoder_count-previous_encoder_count;
      // if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      // else if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      // else {Motor.Speed=dtheta;}
      // previous_encoder_count=encoder_count;

      theta_star=theta_star+Motor.Speed;


    if (test<100){
      pidcontroller.setpoint(theta_eq+theta_0); // The "goal" the PID controller tries to "reach", 
      Motor.PWM = pidcontroller.compute(encoder_count); 
      test=test+1;
    }
    else {

      
      // if  ((theta_eq-theta_0>=1) & (theta_eq+theta_0<tour)){
      //   theta_star=encoder_count-theta_eq;
      //   Motor.Speed=dtheta;
      // } 
      // else {
      //   if (theta_eq-theta_0<1){
      //     if (encoder_count>theta_eq+(3*theta_0)){theta_star=encoder_count-theta_eq-tour;}else{theta_star=encoder_count-theta_eq;}
      // }
      //   if (theta_eq+theta_0>tour){
      //     if (encoder_count<theta_eq-(3*theta_0)){theta_star=tour-theta_eq+encoder_count;}else{theta_star=encoder_count-theta_eq;}
      //   }
      // }

      // else if (theta_eq-theta_0<1){
      //   if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      //   if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      //   if (state){theta_star=encoder_count-theta_eq-tour;}
      //     else{theta_star=encoder_count-theta_eq;Motor.Speed=dtheta;}
      // }
      // else if (theta_eq+theta_0>tour){
      //   if (encoder_count<theta_eq-theta_0){theta_star=tour-theta_eq+encoder_count;}else{theta_star=encoder_count-theta_eq;}
      // }

      Motor.PWM=((-1)*k*(theta_star)/1000)+(bias*Motor.Speed/100);
    }

    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      //Motor.PWM=Motor.PWM+bias;
      motor_ccw(Motor.PWM);}
    else{ // else we move it in a counter clockwise direction
      //Motor.PWM=Motor.PWM-bias;
      motor_cw(abs(Motor.PWM));}

  }    

  ////////////////////////Data format and send
  unsigned long currentMillis5 = millis();
  if (currentMillis5 - previousMillis5 >= 10){//4){   //1/this value=frequency at which messages are sent outward
    previousMillis5 = currentMillis5;    // Save timestamp   
    // Serial.println(currentMillis5);
    // Motor.Angle=map(encoder_count,round(tour/2),tour+round(tour/2),0,1023);
    // Motor.Angle=(Motor.Angle+512)%1023;
    Motor.Angle=encoder_count;
    
    // Serial.print(0);Serial.print(" ");
    // Serial.print(tour);Serial.print(" ");
    // Serial.print(Motor.Speed*100);Serial.print(" ");
    // Serial.print(theta_star);Serial.print(" ");
    // Serial.println(Motor.Angle);

    //ThetaG=atan2((double)accel.acceleration.y,(double)accel.acceleration.x)-(M_PI/4);
    //if (ThetaG<=-M_PI){ThetaG=M_PI/4-abs(ThetaG+M_PI)+(3*M_PI/4);} //rotation of pi/4 to take the plug up as 0 reference
    //Serial.println(ThetaG);
  
    // create JSON object 
    // Declare a buffer to hold the result
    char output[192];// recomended size. can be decreased down to 144 max. https://arduinojson.org/v6/assistant/
    StaticJsonDocument<192> motion;

    // Compute the length of the minified JSON document
    //      int len1=measureJson(motion);
    //      Serial.print("JSON document size:");Serial.println(len1);
    motion["d"] = Motor.Address;
    motion["t"] = millis();
    motion["A"] = Motor.Angle;    
    motion["x"] = accel.acceleration.x;
    motion["y"] = accel.acceleration.y;
    motion["z"] = accel.acceleration.z;
    motion["u"] = gyro.gyro.x;
    motion["v"] = gyro.gyro.y;
    motion["w"] = gyro.gyro.z;
    motion["T"] = Motor.PWM;

    //Serial.println(lsm6dsox.rawAccX);
    
    serializeJson(motion,output);
    //serializeJson(motion,Serial);
    //Serial.println();
    //Serial.print(" ");Serial.println(micros());
    
    //char buffer1[128];
    //memset(buffer1, 0, 6);   
    Udp.beginPacket(udpAddress, outPort);   
    //itoa(Motor.Angle, buffer1,10);
    //Udp.print("A");
    Udp.print(output);
    Udp.endPacket();
    // Serial.print(" ");Serial.println(micros());
    //Serial.println(Motor.Angle);

    }///loop current millis
//
//    unsigned long currentMillis6 = millis();
//    if (currentMillis6 - previousMillis6 >= 10000){   //PID computed value updated every 3ms
//        previousMillis6 = currentMillis6;    // Save timestamp   
//    
//        char bufBat[8];
//        memset(bufBat, 0, 8);
//        bufBat.add(((tp.GetBatteryVoltage()-3.5)/0.70)*100);
//        Udp.beginPacket(udpAddress, outPort);   
//        Udp.print(bufBat);
//        Udp.endPacket();   
//    }
//  //Serial.print(" ");Serial.println(millis());

}   //end void loop