/*Granulobot UDP Firmware V14 
 * Encoder position measurement and conversion in angle and angular velocity
 * Magnet's magnetic field measurement
 * accel + gyr measurement
 * PWM Control of N20 geared motors
 * 2 ways UDP wifi communication with broadcasting address
 * PID on position encoder  https://github.com/DonnyCraft1/PIDArduino
 * https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller
 *  OTA wireless firmware upload: https://randomnerdtutorials.com/esp32-over-the-air-ota-programming/

*      autoselect particule address from database defined in header {IP address number(last digits),paticule adress number}
* New on V13:
*      ??????????
*
*components controlled by the firmware:
*
*accel+gyro: LSM6DSOX 
*magnetic sensor: Tlv493d (+-150mT)
*magnetic encoder: Pololu
*Motor driver: DRV8833
*Microcontroller: ESP32
*StepUp motor: TPS61178 (with Enable Pin)
*
*OpenStageControl ressources:
*https://openstagecontrol.ammd.net/docs/custom-module/custom-module/
*
*by Baudouin Saintyves
*February 11th 2022
*
* Data generated by the robot:
* "{"A":1,"t":97768,"d":5,"x":0.052642,"y":-0.095713,"z":9.818948,"u":0.001222,"v":0.00733,"w":-0.006109}"
*
* for .bin versioning, see https://stackoverflow.com/questions/56923895/auto-increment-build-number-using-platformio
*/

///////Include Local///////////////
//#include "Wifi_Home.h"
//#include "Wifi_NET.h"
#include "Wifi_TP_1.h"
//#include "Wifi_Marc.h"

//IP address of neighbor for handcheck soliton
char udpAddressN[15];

#include "Granulobot_pin_v1_2.h"
//#include "Granulobot_pin_v1_1.h"
//////////////////////////////////

///////MAC ADRESS DATABASE
////add here new two last characters of Mac Address. //Particule number 
// char *ADDRESS_DATA_BASE[] = {  //
//   "FC",//1
//   "08",//2
//   "20",//3
//   "78",//4
//   "38",//5
//   "4C",//6
//   "E8",//7
//   "60",//8
//   "54",//9
//   "88",//10
//   "24",//11
//   "B8",//12
//   "B4",//13
//   "A4",//14
//   "84",//15
//   //add new particule here
//   "00"
// };
//////////////////////////////
char *ADDRESS_DATA_BASE[] = {  //
  "4D:94",//1
  "3E:A8",//2
  "4D:88",//3
  "4D:A4",//4
  "3E:B8",//5
  "4D:B4",//6
  "4D:A8",//7
  "4D:D4",//8
  "4E:24",//9
  "4D:84",//10
  //add new particule here
  "00:00"};

//char *IPparts[sizeof(ADDRESS_DATA_BASE)/sizeof(char *)] ;

/////MOTOR PARAMETERS//////////
//choose here the motor's gear ratio
 const int ratio=379;//986.41;//tour=986*12=11832
 //180deg=5916
 //90deg=2958
 //45deg=1479

//choose here the motor's position PID parameters
#define __Kp 200//260 // Proportional constant
#define __Ki 2 //2.7 Integral Constant
#define __Kd 2000//2000 // Derivative Constant

//choose here the motor's speed PID parameters
#define __Kps 200//260 // Proportional constant
#define __Kis 2 //2.7 Integral Constant
#define __Kds 2000//2000 // Derivative Constant

//choose here motor's PWM frequency
#define FREQ 1000
////////////////////////////////////
////////////////////////////////////

# define M_PI           3.14159265358979323846  /* pi */

////////////////////////////////////
/////EXTERNAL LIBRARIES//////////////////////

 //Arduino
#include <Arduino.h>

  //Wifi
#include <WiFi.h>
#include <WiFiUdp.h>
#include <ESPmDNS.h>
#include <ArduinoOTA.h> //library for Over The Air programming

  //sensors
#include <Adafruit_Sensor.h>
#include <Adafruit_LSM6DSOX.h>//accel+gyro
#include <Adafruit_LSM6DS.h>//accel+gyro
#include <Tlv493d.h>//magnetic field sensor
#include <Wire.h>
#include <Adafruit_INA219.h>//current sensor


  //packet format and parsing for serial com
#include <Regexp.h>
#include <ArduinoJson.h> // tuto https://arduinojson.org/v6/doc/serialization/

  //TinyPico Helper Library
#include <TinyPICO.h>

// //OSC library     https://github.com/CNMAT/OSC
#include <OSCMessage.h> 
#include <OSCBundle.h>
#include <OSCData.h>

  //PID library
#include <PIDController.h> // https://github.com/DonnyCraft1/PIDArduino

  
////particule address number
//int ADDRESS_NUM;

//counter for poke function
int CountPoke=0;

 //Timers
unsigned long previousMillis1 = 0; // store previous millis readout (for PID)
unsigned long previousMillis2 = 0; // store previous millis readout (to send motor.angle)
unsigned long previousMillis3 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis4 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis5 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis6 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis7 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis8 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis9 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis10 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis11= 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis12= 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis13= 0; // store previous millis readout (to send Bat level)

//calibration time = time between two speed increment
unsigned long Cal_time=1000;
const int Cal_interval=5;//jump between 2 PWM value in Cal

//Encoder
volatile int encoder_count=0;
int encoder_count_prev=0;
int encoder_start;
//int prev_count=0;
volatile bool CW;
volatile bool Soft;
const int tour=ratio*12;
const int Res_speed=4;//in ms
int prev_pos=0;
long int speed_tick;
float speed_rad;
int angle_tick=0;
float angle_rad=0;
int speed_target=0;
int direct=0;
int previous=0;
int direct_rec=0;
int k=0;//spring potential
int theta_0=0;
int theta_eq=0;
int theta_star=0;
int bias=0;
int previous_encoder_count=0;
int dtheta=0;
bool state=false;
int dt=0;
int incr_cal;
int sol_amp=0;
//int sol_speed_p=0;
int sol_speed_g=0; //in millisecond, time between two handchecks => equivalent of soliton's group speed
float sol_pulse=0.0;
int sol_period=0;
int Neighbor_address_int=0;
int Part_Sequence_int[sizeof(ADDRESS_DATA_BASE)/sizeof(char *)];
float func_pos=0.0;
int time_count=0;
int Sample_Hand=50;
float refresh=0;
int sol_mode=0;
int Master_dtheta=0;
int Master_Address=0;
int Neighbor_count=0;
int sol_n=4;
int sol_coef[4]={-1,1,-1,1};
int sol_nF=5;
int sol_coefF[5]={0,0,0,0,0};
int sol_coef0=1;
float speed_roll=0;
int AddressLead=0;
int previous_tstar=0;
float speed_roll_meas=0;
int Move_amp=0;
float dt_DR=0;
int sol_PWM=0;
int yield_PWM=0;
//int rel_count=0; //relative displacement in mode 9 = simple speed control
//current sensor
float shuntvoltage = 0;
float busvoltage = 0;
float current_mA = 0;
float loadvoltage = 0;
// float power_mW = 0;

unsigned int angle_target = 0; // stores the incoming serial value. Max value is 65535
char incomingByte; // parses and stores each individual character one by one
//int motor_pwm_value = 255; // after PID computation data is stored in this variable.


struct Button {
  const uint8_t PIN;
  //uint32_t encoder_count;
  bool detect;
};

Button MA = {ENCODER_A, false};//Encoder OUT A
Button MB = {ENCODER_B, false};//Encoder OUT B


//Motor control

//global variables
bool MoveStop=false;
// setting PWM properties
//const int freq = FREQ;
int freq = FREQ;
const int MotChannel1 = 1;
const int MotChannel2 = 2;
const int resolution = 8;

//for PID
//int motor_pwm_value = 0; // after PID computation data is stored in this variable.
unsigned int integerValue = 0;

bool Poke=false;

//for OSC Com
typedef struct Message {
  int Address;
  int Mode;
  int Torque;
  int Max_Torque;
  int Speed;
  int Speed_target;
  int Vshift;
  int Ashift;
  int State;
  //int Displacement;
  int Angle;
  int Angle_target;
  bool Direction;//true=CW or false=CCW
  int PWM; // after PID computation data is stored in this variable.
  int Brake_val;
  bool Minus_State;
  bool Plus_State;
} Message;

int P=0;
int angle_interval;
int test_prev;
int test=0;
int encoder_Shift=0;
int encoder_count_2=0;
int encoder_count_target=0;

float ThetaG;


Message Motor;


///deep sleep
//#define BUTTON_PIN_BITMASK 0x200000000 // 2^33 in hex / for deep sleep on pin 33 with ext1
RTC_DATA_ATTR int bootCount = 0; // for deep sleep
/////////////////////////////////////

//INITIALISE
 //Initialise sensors
    // LSM6DSOX Object
Adafruit_LSM6DSOX lsm6dsox;
    // Tlv493d Object
Tlv493d Tlv493dMagnetic3DSensor = Tlv493d();
    // INA219 current sensor object 
Adafruit_INA219 ina219;
    //create PID object
PIDController pidcontroller;
PIDController pidcontroller_speed;

//create UDP instance
WiFiUDP Udp;
OSCErrorCode error;

// Initialise TinyPICO library
TinyPICO tp = TinyPICO();

//const int capacity=JSON_ARRAY_SIZE(3)+JSON_OBJECT_SIZE(1)+2*JSON_OBJECT_SIZE(3);
const int capacity = JSON_OBJECT_SIZE(9);
StaticJsonDocument<capacity> motion;

////////////////////////////////////
/////FUNCTIONS//////////////////////
void MotorOFF(){
  ledcWrite(MotChannel1, 0);
  ledcWrite(MotChannel2, 0);
  }

void MotorBRAKE(int brake_val){
  ledcWrite(MotChannel1, brake_val);
  ledcWrite(MotChannel2, brake_val);
  }

void MotorDiffPWM(int a,int b){
  ledcWrite(MotChannel1, a);
  ledcWrite(MotChannel2, b);
}
  

void MotorDiffPWM_cw(int power, int Brake){
  ledcWrite(MotChannel1, abs(Brake));
  ledcWrite(MotChannel2, abs(Brake)-abs(power));
  } 

void MotorDiffPWM_ccw(int power, int Brake){
  ledcWrite(MotChannel1, abs(Brake)-abs(power));
  ledcWrite(MotChannel2, abs(Brake));
  }


void motor(int power) {   //fast decay
  if (abs(power) > 20) {
    if (power > 0) {
      //Serial.println("Motor cw");
      ledcWrite(MotChannel1, abs(power));
      ledcWrite(MotChannel2, 0);     
      } 
    else{
      //Serial.println("Motor ccw");
      ledcWrite(MotChannel1, 0);
      ledcWrite(MotChannel2, power);
      }
  } 
  else{
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}

void motor_cw(int power,int tresh) {  //fast decay
  if (power > tresh) {
    //Serial.println("Motor cw");
    ledcWrite(MotChannel1, power);
    ledcWrite(MotChannel2, 0);
  }
  else {
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}
void motor_ccw(int power,int tresh) { //fast decay
  if (power > tresh) {
    //Serial.println("Motor ccw");
    ledcWrite(MotChannel2, power);
    ledcWrite(MotChannel1, 0);
  }
  else {
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}

void motor_cw_s(int power,int tresh) {  //slow decay
  if (power > tresh) {
    //Serial.println("Motor cw");
    ledcWrite(MotChannel1, 255);
    ledcWrite(MotChannel2, 255-power);
  }
  else {
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 255);
    ledcWrite(MotChannel2, 255);
  }
}
void motor_ccw_s(int power,int tresh) {  //slow decay
  if (power > tresh) {
    //Serial.println("Motor ccw");
    ledcWrite(MotChannel2, 255);
    ledcWrite(MotChannel1, 255-power);
  }
  else {
    ledcWrite(MotChannel1, 255);
    ledcWrite(MotChannel2, 255);
  }
}

void motor_cw_s2(int power,int tresh) {  //slow decay
  if (power > tresh) {
    //Serial.println("Motor cw");
    ledcWrite(MotChannel1, 128+round(power/2));
    ledcWrite(MotChannel2, 128-round(power/2));
  }
  else {
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 128);
    ledcWrite(MotChannel2, 128);
  }
}

void CONTROL_SPEED(PIDController PID, int Speed){     
    //Serial.println("control speed");
    int PWM=PID.compute(Speed);
    Serial.print("control speed, PWM= ");Serial.println(PWM);
    if (PWM > 0) // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(PWM,20);
    else // else we move it in a counter clockwise direction
      motor_cw(abs(PWM),20);  
    } 


void displaySensorDetailsISM(void) {
  Serial.print("Accelerometer range set to: ");
  switch (lsm6dsox.getAccelRange()) {
  case LSM6DS_ACCEL_RANGE_2_G:
    Serial.println("+-2G");
    break;
  case LSM6DS_ACCEL_RANGE_4_G:
    Serial.println("+-4G");
    break;
  case LSM6DS_ACCEL_RANGE_8_G:
    Serial.println("+-8G");
    break;
  case LSM6DS_ACCEL_RANGE_16_G:
    Serial.println("+-16G");
    break;
  }
  
  Serial.print("Gyro range set to: ");
  switch (lsm6dsox.getGyroRange()) {
  case LSM6DS_GYRO_RANGE_125_DPS:
    Serial.println("125 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_250_DPS:
    Serial.println("250 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_500_DPS:
    Serial.println("500 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_1000_DPS:
    Serial.println("1000 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_2000_DPS:
    Serial.println("2000 degrees/s");
    break;
  case ISM330DHCX_GYRO_RANGE_4000_DPS:
    Serial.println("4000 degrees/s");
    break;
  }

  Serial.print("Accelerometer data rate set to: ");
  switch (lsm6dsox.getAccelDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }

  Serial.print("Gyro data rate set to: ");
  switch (lsm6dsox.getGyroDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }
}
/*
Method to print the reason by which ESP32
has been awaken from sleep
*/
void print_wakeup_reason(){
  esp_sleep_wakeup_cause_t wakeup_reason;

  wakeup_reason = esp_sleep_get_wakeup_cause();

  switch(wakeup_reason)
  {
    case ESP_SLEEP_WAKEUP_EXT0 : Serial.println("Wakeup caused by external signal using RTC_IO"); break;
    case ESP_SLEEP_WAKEUP_EXT1 : Serial.println("Wakeup caused by external signal using RTC_CNTL"); break;
    case ESP_SLEEP_WAKEUP_TIMER : Serial.println("Wakeup caused by timer"); break;
    case ESP_SLEEP_WAKEUP_TOUCHPAD : Serial.println("Wakeup caused by touchpad"); break;
    case ESP_SLEEP_WAKEUP_ULP : Serial.println("Wakeup caused by ULP program"); break;
    default : Serial.printf("Wakeup was not caused by deep sleep: %d\n",wakeup_reason); break;
  }
}


/////////////////////////////////////
//attach interrupt functions for encoder
void IRAM_ATTR isr_A() {
if (digitalRead(MA.PIN) == HIGH){
    if (digitalRead(MB.PIN) == HIGH){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
else{ if (digitalRead(MB.PIN) == LOW){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }       
MA.detect = true;
}


void IRAM_ATTR isr_B() {
if (digitalRead(MB.PIN) == HIGH){
    if (digitalRead(MA.PIN) == LOW){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
else{
    if (digitalRead(MA.PIN) == HIGH){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
MB.detect = true;
}
///////////////////////////////////////////////
////////////////////////////////////////////////

// void ParseStr(String str, String *Part_Sequence_vec){
//   int StringCount = 0;
//   // Split the string into substrings
//   while (str.length() > 0)
//   {
//     int index = str.indexOf(' ');
//     if (index == -1) // No space found
//     {
//       Part_Sequence_vec[StringCount++] = str;
//       break;
//     }
//     else
//     {
//       Part_Sequence_vec[StringCount++] = str.substring(0, index);
//       str = str.substring(index+1);
//     }
//   }
// }

/////rewrite this from parser in HandInit
void ParseStr(String str, String *Part_Sequence_vec){
  int StringCount = 0;
  // Split the string into substrings
  while (str.length() > 0)
  {
    int index = str.indexOf(' ');
    if (index == -1) // No space found
    {
      Part_Sequence_vec[StringCount++] = str;
      break;
    }
    else
    {
      Part_Sequence_vec[StringCount++] = str.substring(0, index);
      str = str.substring(index+1);
    }
  }
}


void setup(){

  Wire.setClock(400000); //test 
  
  // log_d("Total heap: %d", ESP.getHeapSize());//core debug level to "verbose"
  // log_d("Free heap: %d", ESP.getFreeHeap());
  // log_d("Total PSRAM: %d", ESP.getPsramSize());
  // log_d("Free PSRAM: %d", ESP.getFreePsram());
  
  Serial.begin(115200);
  Serial.println("RESET");
  Serial.println("Firmware Granulobot UDP V14");


//WIFI UDP SETUP

  //Connect to the WiFi network
  WiFi.begin(ssid, pwd);
  Serial.println("");

  Serial.print("ESP Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
  // Wait for connection
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  //This initializes udp and transfer buffer
  Udp.begin(localPort);
  strcpy(udpAddress,udpAddress0); 
  ///////


//////ARDUINO OTA 
ArduinoOTA
    .onStart([]() {
      String type;
      if (ArduinoOTA.getCommand() == U_FLASH)
        type = "sketch";
      else // U_SPIFFS
        type = "filesystem";

      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
      Serial.println("Start updating " + type);
    })
    .onEnd([]() {
      Serial.println("\nEnd");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      Serial.printf("Error[%u]: ", error);
      if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
      else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
      else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
      else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
      else if (error == OTA_END_ERROR) Serial.println("End Failed");
    });

  ArduinoOTA.begin();
  /////////////////////////////////////
//  
////  //particule address selection  
  std::string EndMAC{WiFi.macAddress()[12],WiFi.macAddress()[13],WiFi.macAddress()[14],WiFi.macAddress()[15],WiFi.macAddress()[16]};
  int index=0;
  for (int i=0; i<(sizeof(ADDRESS_DATA_BASE) / sizeof(ADDRESS_DATA_BASE[0])); i++) {
     if (EndMAC == ADDRESS_DATA_BASE[i]) {
       index = i;
       // Serial.print(local[5],HEX);
        Serial.print((sizeof(ADDRESS_DATA_BASE) / sizeof(ADDRESS_DATA_BASE[0])));Serial.print(" adresses to choose from, index: ");Serial.println(index);    
       break;
     }
     else{Serial.println("No adress found ");index=-1;}
  }
  IPAddress local=WiFi.localIP();

//Serial.print("Two last char of MAC address: ");Serial.println(EndMAC);

// 
 //intitialisation of Motor structure
  //Motor.Address=ADDRESS_DATA_BASE[index][1];//ADDRESS
  Motor.Address=index+1;//ADDRESS
  Motor.Mode=0;
  Motor.Speed=0;
  Motor.Speed_target=5;
  Motor.Torque=0;
  Motor.Max_Torque=255;
  Motor.Angle=0;
  Motor.Angle_target=0;
  Motor.Direction=true;
  Motor.State=0;
  Motor.PWM=0;
  Motor.Vshift=0;
  Motor.Minus_State=false;
  Motor.Plus_State=false;
 Serial.print("Motor address:");Serial.println(Motor.Address);
  
/////deep sleep mode setup
++bootCount;
  Serial.println("Boot number: " + String(bootCount));

  //Print the wakeup reason for ESP32
  print_wakeup_reason();

  /*
  First we configure the wake up source
  We set our ESP32 to wake up for an external trigger.
  There are two types for ESP32, ext0 and ext1 .
  ext0 uses RTC_IO to wakeup thus requires RTC peripherals
  to be on while ext1 uses RTC Controller so doesnt need
  peripherals to be powered on.
  Note that using internal pullups/pulldowns also requires
  RTC peripherals to be turned on.
  */
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_5,1); //1 = High, 0 = Low

  /////////

  tp.DotStar_SetPower(true);
  tp.DotStar_SetPixelColor(0,200,0);
  tp.DotStar_Show();
  delay(2000);
  ///turn off RGB LED power to save battery life
  tp.DotStar_SetPower(false);
  
  
  ////SETUP SENSORS
  //Tlv493d
  Tlv493dMagnetic3DSensor.begin();
  Serial.println("Tlv493d Found!");

    //LSM6DSOX

    lsm6dsox.setAccelRange(LSM6DS_ACCEL_RANGE_8_G);
    lsm6dsox.setGyroRange(LSM6DS_GYRO_RANGE_2000_DPS); 
    lsm6dsox.setAccelDataRate(LSM6DS_RATE_3_33K_HZ);
    lsm6dsox.setGyroDataRate(LSM6DS_RATE_3_33K_HZ);

  while (!Serial)
    delay(10); // will pause Zero, Leonardo, etc until serial console opens 

  Serial.println("Adafruit lsm6dsox test!");

  if(!lsm6dsox.begin_I2C(0x6A)){
    Serial.println("Failed first attempt");
    if(!lsm6dsox.begin_I2C(0x6B)){
      Serial.println("Failed to find lsm6dsox chip");
      while (1) delay(10);
    }
  }

  Serial.println("lsm6dsox Found!");

  delay(500);

  if (! ina219.begin()) {
    Serial.println("Failed to find INA219 chip");
    while (1) { delay(10); }
  }
  Serial.println("INA219 Found!");

    //Encoder
  pinMode(MA.PIN, INPUT);
  attachInterrupt(MA.PIN, isr_A, CHANGE);
  pinMode(MB.PIN, INPUT);
  attachInterrupt(MB.PIN, isr_B, CHANGE);
  Serial.print("ticks per tour=");Serial.println(tour);
  ////////


  //ENABLE BOOST
  pinMode(EN_BOOST, OUTPUT);
  digitalWrite(EN_BOOST, HIGH);// Start with Boost on.  

  //MOTOR SETUP
    //Initialize the motor driver switch pin.
  pinMode(MOT_SLP_PIN, OUTPUT);
  digitalWrite(MOT_SLP_PIN, HIGH);// Start with drivers on.
    //PWM setup 
  ledcSetup(MotChannel1, freq, resolution);
  ledcSetup(MotChannel2, freq, resolution);

  ledcAttachPin(MOT_A1_PIN, MotChannel1);
  ledcAttachPin(MOT_A2_PIN, MotChannel2);
  ///////
  
  //PID
  pidcontroller.begin(); // initialize the PID instance
  pidcontroller.tune(__Kp,__Ki,__Kd); // Tune the PID, arguments: kP, kI, kD
  pidcontroller.limit((-1)*Motor.Max_Torque, Motor.Max_Torque); // Limit the PID output between -255 to 255, this is important to get rid of integral windup!


  //PID speed
  pidcontroller_speed.begin(); // initialize the PID instance
  pidcontroller_speed.tune(__Kps,__Kis,__Kds); // Tune the PID, arguments: kP, kI, kD
  pidcontroller_speed.limit((-1)*Motor.Max_Torque, Motor.Max_Torque); // Limit the PID output between -255 to 255, this is important to get rid of integral windup!

   Serial.print("PWM freq= ");Serial.println(FREQ);

//// Get a *rough* estimate of the current battery voltage
  // If the battery is not present, the charge IC will still report it's trying to charge at X voltage
  // so it will still show a voltage.
  Serial.print("Battery level: ");
  Serial.println(tp.GetBatteryVoltage());
  Serial.print("Battery charging in progress: ");
  Serial.println(tp.IsChargingBattery());  
  delay(2000);
  Serial.print("battery level= ");Serial.print(((tp.GetBatteryVoltage()-3.5)/0.70)*100);Serial.println("%");

  //initialize counter for Calibration procedure
  int incr_cal=(-1)*Cal_interval;

}//end setup loop

void loop(){
  //Serial.print(micros());

  //Handle to execut for new firmware upload 
  ArduinoOTA.handle();
  
  
  /* Get a new normalized sensor event */
  sensors_event_t accel;
  sensors_event_t gyro;
  sensors_event_t temp;
  //Serial.print(" "); Serial.println(micros());

  lsm6dsox.getEvent(&accel, &gyro, &temp);

  //Serial.println(millis());
  //Serial.println(lsm6dsox.rawAccX);

  //angle encoder increment definition theta=encoder_count in [0 tour] with tour= gear ration * 12 
  if (encoder_count>tour-1){encoder_count=encoder_count-tour;}   
  if (encoder_count<0){encoder_count=tour+encoder_count;}
  //Serial.println(encoder_count);

  ////READ SPEED FROM SERVER
  char buffer4[40];
  memset(buffer4, 0, 40);     
  Udp.parsePacket(); 
  if(Udp.read(buffer4, 40) > 0){
    //Serial.println("Message received");

    MatchState ms;
    ms.Target(buffer4);      
    //Serial.println(buffer4);
    
    char resultIP=ms.Match ("(IP)(%d+.%d+.%d+.%d+)",0);
    //Serial.println(resultIP);
    if (resultIP == REGEXP_MATCHED){
      char captureBufIP [20];
      strcpy(udpAddress, ms.GetCapture (captureBufIP,1));
      Serial.print("Telemetry com IP changed to ");Serial.println(udpAddress);
    }  

    
    char resultPoke=ms.Match ("(Po)",0);
    //Serial.println(resultPoke);
    if (resultPoke == REGEXP_MATCHED){
      Serial.println("Poke");
      Poke=1; 
      previousMillis1 = millis();
    }  

    char resultCal=ms.Match ("(Cal;)",0);
    if (resultCal == REGEXP_MATCHED){
      Serial.println("Enter Calibration Procedure - Fast decay");
      Motor.State=3; 
      encoder_count_prev=encoder_count; 
      incr_cal=(-1)*Cal_interval;         
    } 

    char resultCalS=ms.Match ("(CalS;)",0);
    if (resultCalS == REGEXP_MATCHED){
      Serial.println("Enter Calibration Procedure - Slow decay");
      Motor.State=10; 
      encoder_count_prev=encoder_count; 
      incr_cal=(-1)*Cal_interval;         
    } 


    char resultCalS2=ms.Match ("(CalS2;)",0);
    if (resultCalS2 == REGEXP_MATCHED){
      Serial.println("Enter Calibration Procedure - Slow decay 128");
      Motor.State=11; 
      encoder_count_prev=encoder_count; 
      incr_cal=(-1)*Cal_interval;        
    } 

    char resultPWMF=ms.Match ("(PWMF)(%d+)(;)",0);//update 5/21/2022
    if (resultPWMF == REGEXP_MATCHED){
      char bufferPWMF[10];
      freq=atoi(ms.GetCapture(bufferPWMF,1));
      ledcSetup(MotChannel1, freq, resolution);
      ledcSetup(MotChannel2, freq, resolution);
      ledcAttachPin(MOT_A1_PIN, MotChannel1);
      ledcAttachPin(MOT_A2_PIN, MotChannel2);
      Serial.print("PWM frequency changed to ");Serial.println(freq);       
    } 
    
    
    char resultC_time=ms.Match ("(C_time)(%d+)(;)",0);//update 5/21/2022
    if (resultC_time == REGEXP_MATCHED){
      char bufferC_time[10];
      Cal_time=atoi(ms.GetCapture(bufferC_time,1));
      Serial.print("Calibration time changed to ");Serial.println(Cal_time);       
    } 


// Init all procdure with handcheck or altenrating speed sign (requier to now direct neighbor) 
    char resultHandi=ms.Match ("(HandInit)(%s)(.+)(;)",0);
    //char resultHandi=ms.Match ("(HandInit)(%s)(.+)(n)(%d+)(;)",0);
    if (resultHandi == REGEXP_MATCHED){
      time_count=0;
      tp.DotStar_SetPower(false);
      encoder_count_prev=encoder_count;

      Serial.println("Handcheck Soliton init");
      char Part_Sequence_raw [45];
      
      memset(Part_Sequence_raw,0,40);
      ms.GetCapture(Part_Sequence_raw,2);
      int sizeSeqRaw=0;

       for (int i = 0; i < sizeof(Part_Sequence_raw)/sizeof(Part_Sequence_raw[0]); i++){
        if (Part_Sequence_raw[i] != 0){sizeSeqRaw++;} 
       }

      //Serial.print("Bots sequence: ");Serial.println(Part_Sequence_raw);
      int SpCount=0;
      int SpArr[sizeSeqRaw];
      String Part_Sequence[sizeSeqRaw];
      
    //command sent from terminal: cmd all HandInit /1/10/3/8/9/2/5/4/;
      //Serial.print("separators at ");
      SpArr[0]=0;     
      for (int i = 0; i <sizeSeqRaw; i++){
        if(Part_Sequence_raw[i]=='/'){ //char(32) corresponds to a space ' '
          SpArr[SpCount]=i;
          //Serial.print(SpArr[SpCount]);Serial.print(' ');
          SpCount++;
        }
      }
      //Serial.println();
  
      //Serial.println("Parsed sequence: ");
      for (int i = 0; i <SpCount-1; i++){
        for (int j = SpArr[i]+1; j <SpArr[i+1]; j++){
          Part_Sequence[i]=Part_Sequence[i]+Part_Sequence_raw[j];
        }
        //n = Part_Sequence[i].length();
        //char Neighbor_address[n + 1];
        Part_Sequence_int[i]=atoi(Part_Sequence[i].c_str());
        //Serial.println(Part_Sequence[i]);
        //Serial.println(Part_Sequence_int[i]);
      }
      
      int Seq_pos=0;
      for (int i = 1; i <SpCount; i++){
          if(String(Motor.Address)==Part_Sequence[i-1]){
            Seq_pos=i;     
            //Serial.print("pos in seq: ");Serial.println(Seq_pos);      
          }
      }
      Serial.print("pos in seq: ");Serial.println(Seq_pos);
      Serial.print("size: ");Serial.println(SpCount-1);

      if (Seq_pos!=SpCount-1){
        // n = Part_Sequence[Seq_pos+1].length();
        // char Neighbor_address[n + 1];
        // strcpy(Neighbor_address, Part_Sequence[Seq_pos+1].c_str());
        // Neighbor_address_int=atoi(Neighbor_address);
        Neighbor_address_int=Part_Sequence_int[Seq_pos];
      } else {
          Neighbor_address_int=Part_Sequence_int[0];
          // n = Part_Sequence[0].length();
          // char Neighbor_address[n + 1];
          // strcpy(Neighbor_address, Part_Sequence[0].c_str());
          // Neighbor_address_int=atoi(Neighbor_address);     
      }
      if (Seq_pos==0){Neighbor_address_int=0;}

      Serial.print("neighbor address: ");Serial.println(Neighbor_address_int);


      //Motor.State=4; 
      encoder_count_prev=encoder_count;
      // //ParseStr(Part_Sequence_raw, Part_Sequence_vec[30]);
      String buf =  String("d"+String(Motor.Address)+"-" + WiFi.localIP()[0]+'.'+ WiFi.localIP()[1]+'.'+ WiFi.localIP()[2]+'.'+ WiFi.localIP()[3]+';');   
      Serial.print("IP message sent: ");Serial.println(buf);

      //sol_n = atoi(ms.GetCapture (Part_Sequence_raw,4));

      Udp.beginPacket(udpAddress0, localPort);   
      //itoa(Motor.Angle, buffer1,10);
      //Udp.print("A");
      Udp.print(buf);
      Udp.endPacket();

    } 

    char resultIPpart=ms.Match ("(d)(%d+)(-)(%d+.%d+.%d+.%d+)(;)",0);
    if (resultIPpart == REGEXP_MATCHED){
      char captureBufIPpart [20];   
      Serial.print("IP received from particule "); Serial.println(ms.GetCapture (captureBufIPpart,1));
      Serial.println(ms.GetCapture (captureBufIPpart,3));
      if (atoi(ms.GetCapture (captureBufIPpart,1))==Neighbor_address_int){
        strcpy(udpAddressN,ms.GetCapture (captureBufIPpart,3));
        Serial.print("Neighbor's IP: ");Serial.println(udpAddressN);  
      }     
      // IPparts[atoi(ms.GetCapture (captureBufIPpart,0))]=ms.GetCapture (captureBufIPpart,2);
      // strcpy(udpAddressN,IPparts[Neighbor_address_int]);
      // Serial.print("Neighbor's IP: ");Serial.println(udpAddressN);  
    } 


//change kinematic coef for Handcheck based displacement control soliton 
    char resultHandCoef=ms.Match ("(HandC)(%+?%-?%d+)(,)(%+?%-?%d+)(,)(%+?%-?%d+)(,)(%+?%-?%d+)(,)(%+?%-?%d+)(;)",0);
    if (resultHandCoef == REGEXP_MATCHED){
      char captureBufHandCoef [35];     
      Serial.println("Handcheck Soliton Coef changed");  
  
      sol_coef0=atoi(ms.GetCapture (captureBufHandCoef,1));
      sol_coef[0]=atoi(ms.GetCapture (captureBufHandCoef,3));
      sol_coef[1]=atoi(ms.GetCapture (captureBufHandCoef,5));
      sol_coef[2]=atoi(ms.GetCapture (captureBufHandCoef,7));
      sol_coef[3]=atoi(ms.GetCapture (captureBufHandCoef,9));
    } 


////change PID parameters for speed
    char resultPIDS=ms.Match ("(PIDS)(P)(%d+)(I)(%d+)(D)(%d+)(;)",0);
    if (resultPIDS == REGEXP_MATCHED){
      char captureBufPIDS [30];     
      Serial.println("Speed PID parameters changed");  
      pidcontroller_speed.tune(atoi(ms.GetCapture (captureBufPIDS,2)),atoi(ms.GetCapture (captureBufPIDS,4)),atoi(ms.GetCapture (captureBufPIDS,6))); // Tune the PID, arguments: kP, kI, kD
      Serial.print("P= ");Serial.print(atoi(ms.GetCapture (captureBufPIDS,2)));
      Serial.print(" I= ");Serial.print(atoi(ms.GetCapture (captureBufPIDS,4)));
      Serial.print(" D= "); Serial.println(atoi(ms.GetCapture (captureBufPIDS,6)));
    }



/////kinematic soliton (displacement controlled perturbation propagation)
    char resultHand=ms.Match ("(Hand)(T)(%d+)(A)(%d+)(SG)(%d+)(;)",0);
    if (resultHand == REGEXP_MATCHED){
      
      
      tp.DotStar_SetPower(false);  
      char captureBufHand [35];     
      Serial.print("Handcheck Soliton ON, first bots ");  
      time_count=0;

      //Motor.State=4;// for angle constrain


      Serial.println(Part_Sequence_int[0]);  
      encoder_count_prev=encoder_count;
      //sol_pulse = atoi(ms.GetCapture (captureBufHand,2));
      sol_period = atoi(ms.GetCapture (captureBufHand,2));
      sol_amp = atoi(ms.GetCapture (captureBufHand,4));
      //sol_speed_p = atoi(ms.GetCapture (captureBufHand,6));
      sol_speed_g = atoi(ms.GetCapture (captureBufHand,6));
     

      //theta_eq=encoder_count; 
      theta_star=0;
      refresh=round(sol_period/Sample_Hand);  
      //Serial.print("refresh period: "); Serial.println(refresh);

      //Serial.print("pulsation = ");Serial.print(sol_pulse);
      Serial.print("Amplitude = ");Serial.print(sol_amp);Serial.print(", Speed = ");Serial.println(sol_speed_g);   
      if(Motor.Address==Part_Sequence_int[0]){
        Udp.beginPacket(udpAddressN, localPort);   
        char bufcheck[3]={'O',';'};  
        Udp.print(bufcheck);
        Udp.endPacket();
      }
       
    } 

    char resultHandStop=ms.Match ("(HandStop;)",0);
    if (resultHandStop == REGEXP_MATCHED){
      Serial.println("Soliton STOP");
      Motor.PWM=0;
      Motor.State=0;
      tp.DotStar_SetPower(false);

    }

    char resultCHECK=ms.Match ("(O;)",0);
    if (resultCHECK == REGEXP_MATCHED){
      //Serial.println("Neighbor Master CHECK");
      Motor.State=4;// remove for angle constrain
      sol_mode=1;
      Neighbor_count=0;
      //time_count=0; //for angle constrain
      
      previousMillis7 = millis();
      previousMillis8 = millis();
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(30,0,30);
      tp.DotStar_Show(); 

      Udp.beginPacket(udpAddressN, localPort); 
      char bufcheckTS[6];
      memset(bufcheckTS, 0, 6); 
      sprintf(bufcheckTS,"TS%i;",Neighbor_count);       
      //Serial.println(bufcheckTS);
      Udp.print(bufcheckTS);
      Udp.endPacket();

    }  


    char resultTrigSlave=ms.Match ("(TS)(%d+)(;)",0);
    //char resultC=ms.Match ("(M%s)(%d+)(%s)(/)(%s)(%d+)(%s)(/)(%s)(%d+)(%s)(;)",0);
    if (resultTrigSlave == REGEXP_MATCHED){
      
      char captureBufTrigSlave [10];  
      
      Neighbor_count=atoi(ms.GetCapture (captureBufTrigSlave,1))+1;
      Serial.print("Neighbor Slave CHECK to i+");Serial.println(Neighbor_count);

      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(0,0,30);
      tp.DotStar_Show(); 

      if (Neighbor_count<sol_n){
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckTS[6];
        memset(bufcheckTS, 0, 6); 
        sprintf(bufcheckTS,"TS%i;",Neighbor_count);       
        //Serial.println(bufcheckTS);
        Udp.print(bufcheckTS);
        Udp.endPacket();
      }
    }  

    char resultC=ms.Match ("(M)(%+?%-?%d+)(;)",0);
    //char resultC=ms.Match ("(M)(%d+)(/)(%d+)(/)(%d+)(;)",0);
    //char resultC=ms.Match ("(M%s)(%d+)(%s)(/)(%s)(%d+)(%s)(/)(%s)(%d+)(%s)(;)",0);
    if (resultC == REGEXP_MATCHED){
      //Serial.println("Neighbor Slave CHECK");
      char captureBufS [15];  
      Motor.State=4;// remove for angle constrain
      sol_mode=2;
      //time_count=0; //for angle constrain
      //Master_Address=atoi(ms.GetCapture (captureBufS,1));
      Master_dtheta=atoi(ms.GetCapture (captureBufS,1));
      //Neighbor_count=atoi(ms.GetCapture (captureBufS,5))+1;

      //previousMillis7 = millis();
      //previousMillis8 = millis();
      //tp.DotStar_SetPower(true);
      //tp.DotStar_SetPixelColor(0,0,30);
      //tp.DotStar_Show(); 

      if (Neighbor_count<sol_n){
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckS[15];
        memset(bufcheckS, 0, 15); 
        sprintf(bufcheckS,"M%i;", Master_dtheta);       
        //Serial.println(bufcheckS);
        Udp.print(bufcheckS);
        Udp.endPacket();
      }

    }  



    /////roll mode with master and slave.
    //char resultHandRoll=ms.Match ("(HandRoll)(%d)(/)(%+?%-?%d+)/(%d)(;)",0);
    char resultHandRoll=ms.Match ("(HandRoll)(%d)(/)(%+?%-?%d+)(;)",0);
    if (resultHandRoll == REGEXP_MATCHED){
      char captureBufRoll [25];     
      //pidcontroller.setpoint(0);
      Serial.print("Hand Roll mode, Speed=");  
      theta_star=0;
      previous_tstar=0;
      Motor.State=5;
      AddressLead=atoi(ms.GetCapture (captureBufRoll,1));
      speed_roll=atoi(ms.GetCapture (captureBufRoll,3));
      //Move_amp=atoi(ms.GetCapture (captureBufRoll,5));
      Serial.println(speed_roll);
      if (Motor.Address==AddressLead){ 
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(30,0,30);
      tp.DotStar_Show(); 
      }

    } 

    //char resultSlaveR=ms.Match ("(MR)(%d+)(/)(%+?%-?%d)(;)",0);
    char resultSlaveR=ms.Match ("(MR)(%+?%-?%d+)(;)",0);
    if (resultSlaveR == REGEXP_MATCHED){
      //Serial.println("Neighbor Slave CHECK");
      char captureBufSlaveR [15];  
      Master_dtheta=(-1)*atoi(ms.GetCapture (captureBufSlaveR,1));
      //coef_roll=atoi(ms.GetCapture (captureBufSlaveR,3));
      previousMillis7 = millis();
      
      if (Neighbor_address_int!=AddressLead){
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckS[15];
        memset(bufcheckS, 0, 15); 
        sprintf(bufcheckS,"MR%i;", Master_dtheta);       
        //Serial.println(bufcheckS);
        Udp.print(bufcheckS);
        Udp.endPacket();
      }

      Motor.State=5;// remove for angle constrain

    }  
    //////////////////////////////////////



    /////direct roll mode 
    //char resultHandRoll=ms.Match ("(HandRoll)(%d)(/)(%+?%-?%d+)/(%d)(;)",0);
    char resultDRoll=ms.Match ("(DR)(%+?%-?%d+)(;)",0);
    if (resultDRoll == REGEXP_MATCHED){
      char captureBufDRoll [25];     
      //pidcontroller.setpoint(0);
      //Serial.println("Direct Roll mode, sequence=");  
      Serial.print("Direct Roll mode, speed=");  
      theta_star=0;
      previous_tstar=0;
      dt_DR=5E-3;
      
      for (int i = 0; i <sizeof(ADDRESS_DATA_BASE)/sizeof(char *); i++){
      //Serial.println(Part_Sequence_int[i]); 
        if (Motor.Address==Part_Sequence_int[i]){
         speed_roll=(pow(-1,i+1))*atof(ms.GetCapture (captureBufDRoll,1))*dt_DR;//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
         Serial.println(speed_roll);
         //Serial.println(1000*dt_DR);
         //Serial.print("Position in sequence: "); Serial.println(i+1);
        }
      
      }
    
      Motor.State=6;
      previousMillis9 = millis(); 

    } 

//////////////////Driect Force (PWM) controled roll (Soften the system at the treshold)
    char resultDRollF=ms.Match ("(DRF)(%+?%-?%d+)(;)",0);
    if (resultDRollF == REGEXP_MATCHED){
      char captureBufDRollF [25];     
      Serial.print("Direct constant force Roll mode, PWM=");       
      for (int i = 0; i <sizeof(ADDRESS_DATA_BASE)/sizeof(char *); i++){
        if (Motor.Address==Part_Sequence_int[i]){
         Motor.PWM=(pow(-1,i+1))*atoi(ms.GetCapture (captureBufDRollF,1));//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
        }  
      }
      Motor.State=7;
      Serial.println(Motor.PWM);
    } 

//////////////////Force (PWM) controled soliton
    char resultHandF=ms.Match ("(HandF)(%d+)(/P)(%+?%-?%d+)(Y)(%d+)(SG)(%d+)(;)",0);
    if (resultHandF == REGEXP_MATCHED){
      
      tp.DotStar_SetPower(false);  
      char captureBufHandF [35];     
      Serial.print("Handcheck Force Soliton ON, first bot: next one after ");   
      
      AddressLead=atoi(ms.GetCapture (captureBufHandF,1));

      Serial.println(AddressLead);  
      sol_PWM = atoi(ms.GetCapture (captureBufHandF,3));
      yield_PWM= atoi(ms.GetCapture (captureBufHandF,5));
      sol_speed_g = atoi(ms.GetCapture (captureBufHandF,7));

      sol_coefF[0]=(-1)*sol_PWM;
      sol_coefF[1]=0;
      sol_coefF[2]=(-1)*yield_PWM;
      sol_coefF[3]=yield_PWM;
      sol_coefF[4]=(-1)*yield_PWM;
     
      Serial.print("Particule Start = ");Serial.print(AddressLead);
      Serial.print(", Active force = ");Serial.print(sol_PWM);
      Serial.print(", Yield = ");Serial.print(yield_PWM);
      Serial.print(", Handcheck time = ");Serial.println(sol_speed_g);   
      
      if(Motor.Address==AddressLead){
        Udp.beginPacket(udpAddressN, localPort);   
        char bufcheckF[5]={'O','F',';'};  
        Udp.print(bufcheckF);
        Udp.endPacket();
      }
       
    } 


char resultCHECKF=ms.Match ("(OF;)",0);
    if (resultCHECKF == REGEXP_MATCHED){
      Serial.println("Neighbor Master CHECK received");
      Motor.State=8;
      
      Neighbor_count=0;
    
      Motor.PWM=sol_PWM;
      
  
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(30,0,30);
      tp.DotStar_Show(); 

      Udp.beginPacket(udpAddressN, localPort); 
      char bufcheckTSF[7];
      memset(bufcheckTSF, 0, 7); 
      sprintf(bufcheckTSF,"TSF%i;",Neighbor_count);       
      //Serial.println(bufcheckTS);
      Udp.print(bufcheckTSF);
      Udp.endPacket();

      previousMillis10 = millis();

    }  


    char resultTrigF=ms.Match ("(TSF)(%d+)(;)",0);
    //char resultC=ms.Match ("(M%s)(%d+)(%s)(/)(%s)(%d+)(%s)(/)(%s)(%d+)(%s)(;)",0);
    if (resultTrigF == REGEXP_MATCHED){
      
      char captureBufTrigF [11];  
      
      Neighbor_count=atoi(ms.GetCapture (captureBufTrigF,1))+1;
      Serial.print("Neighbor Slave CHECK to i+");Serial.println(Neighbor_count);
      //Serial.println("Neighbor slave CHECK received");

      Motor.PWM=sol_coefF[Neighbor_count-1];
      
      //Serial.print("PWM=");Serial.println(Motor.PWM);
      
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(0,0,30);
      tp.DotStar_Show(); 

      if (Neighbor_count<sol_nF){
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckTS[7];
        memset(bufcheckTS, 0, 7); 
        sprintf(bufcheckTS,"TSF%i;",Neighbor_count);       
        //Serial.println(bufcheckTS);
        Serial.println("Neighbor slave CHECK sent");

        Udp.print(bufcheckTS);
        Udp.endPacket();
      }

      Motor.State=7;
    }  

///////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////


///adjust to not come back to old last position of stiff mode
    char resultStiff=ms.Match ("(Stiff)",0);
    if (resultStiff == REGEXP_MATCHED){
      Serial.println("Motor state ON");
      Motor.State=1; 
      encoder_count_prev=encoder_count;          
    } 
    
    char resultSoft=ms.Match ("(Soft)",0);
    if (resultSoft == REGEXP_MATCHED){
      Serial.println("Motor state OFF");
      Motor.State=0; 
    } 

    char resultSpr=ms.Match ("(Spr)(%s)(%a)(%d+)(b)(%d+)(;)",0);// choose bias in the range 0-500|||choose k in the range 0-1000
    if (resultSpr == REGEXP_MATCHED){ 
      char captureBufSpr [15];     
      Motor.State=2;
      theta_eq=encoder_count; 
      theta_star=0;  
      test=0;
      bias=atoi(ms.GetCapture (captureBufSpr,5));
      Serial.println("Spring mode");
      Serial.print("Theta_eq=");Serial.println(theta_eq);
      Serial.print("bias= ");Serial.println(bias);
      Serial.print("max PWM=");Serial.println(Motor.Max_Torque);
      //Serial.print("buffer 2 =");Serial.println(ms.GetCapture (captureBufSpr,2));

      if (!strcmp(ms.GetCapture (captureBufSpr,2),"k")){
        k=atoi(ms.GetCapture (captureBufSpr,3)); 
        //theta_0=(Motor.Max_Torque-bias)*1000/k;
        theta_0=(Motor.Max_Torque)*1000/k;
        Serial.print("control k=");Serial.println(k);
        Serial.print("Theta_0=");Serial.println(theta_0);

      }
        
      if (!strcmp(ms.GetCapture (captureBufSpr,2),"t")){
        theta_0=atoi(ms.GetCapture (captureBufSpr,3)); 
        //k=(Motor.Max_Torque-bias)*1000/(theta_0);
        k=(Motor.Max_Torque)*1000/(theta_0);
        Serial.print("control Theta_0=");Serial.println(theta_0);
        Serial.print("k=");Serial.println(k);   
      }
        //k=atoi(ms.GetCapture (captureBufSpr,1)); 
        //theta_0=atoi(ms.GetCapture (captureBufSpr,3));    
    } 
    
    char resultSleep=ms.Match ("(Sl)",0);
      if (resultSleep == REGEXP_MATCHED){
        Serial.println("Going to sleep now");
        ledcWrite(MotChannel2,0);
        ledcWrite(MotChannel1,0);
        ///turn off RGB LED power to save battery life
        tp.DotStar_SetPower(true);
        tp.DotStar_SetPixelColor(30,0,0);
        tp.DotStar_Show();
        delay(2000);
        tp.DotStar_SetPower(false);
        esp_deep_sleep_start();
        delay(1000);  
      }  

    char resultSp=ms.Match ("(Sp)(%d+)(;)",0);
      if (resultSp == REGEXP_MATCHED){
        char captureBufSp [8];
        //Motor.Speed=atoi(ms.GetCapture (captureBufSp,1)); 
        Motor.Max_Torque=atoi(ms.GetCapture (captureBufSp,1));
        Serial.print("pid controller PWM limit= ");Serial.println(atoi(ms.GetCapture (captureBufSp,1)));
        pidcontroller.limit(Motor.Max_Torque*(-1), Motor.Max_Torque); // Limit the PID output between -Motor.Speed to Motor.Speed, this is important to get rid of integral windup!
        pidcontroller_speed.limit(Motor.Max_Torque*(-1), Motor.Max_Torque);
      }

  //       char resultPW=ms.Match ("(PW)(%-?%+?%d+)(;)",0);
  //        if (resultPW == REGEXP_MATCHED){
  //          char captureBufPW [8];
  //          Motor.PWM=atoi(ms.GetCapture (captureBufPW,1)); 
  //          Serial.println("Motor.PWM=");Serial.println(Motor.PWM);
  //          pidcontroller.limit( Motor.Speed*(-1), Motor.Speed); // Limit the PID output between -Motor.Speed to Motor.Speed, this is important to get rid of integral windup!
  //        }
        
      char resultA=ms.Match ("(A)(%d+)(;)",0);
      if (resultA == REGEXP_MATCHED){
        char captureBufA [8];
        //encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count;
        //if (encoder_Shift<(-1)*tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count+tour;}    
        //if (encoder_Shift>tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count-tour;}    
        Motor.Angle_target=atoi(ms.GetCapture (captureBufA,1));  
        //Serial.print("Motor.Angle_target=");Serial.println(Motor.Angle_target);  
        Serial.print("Angle target= ");Serial.print(Motor.Angle_target);
        Serial.print(" encoder= ");Serial.println(encoder_count); //Serial.print(" shift = ");Serial.println(encoder_Shift);
        //encoder_count_prev=atoi(ms.GetCapture (captureBufA,1));   
        encoder_count_prev=encoder_count;  
        //Motor.Ashift=encoder_Shift;   
      }

      char resultM=ms.Match ("(MA)(%+?%-?%d+)(;)",0);
      if (resultM == REGEXP_MATCHED){
        char captureBufM [8];
        //ms.GetCapture (captureBufM,1);
        //encoder_Shift=encoder_count_prev+atoi(ms.GetCapture(captureBufM,1));
        //encoder_Shift=atoi(ms.GetCapture(captureBufM,1));
        //Serial.println(captureBufM);
        // if (captureBufM[0]=='+'){Motor.Minus_State=false;Motor.Plus_State=true;Serial.println("Move +");}  
        // if (captureBufM[0]=='-'){Motor.Minus_State=true;Motor.Plus_State=false;Serial.println("Move -");} 
        //Motor.Angle_target=(encoder_count_prev+atoi(ms.GetCapture(captureBufM,1)))%tour; 
        Motor.Angle_target=(encoder_count+atoi(ms.GetCapture(captureBufM,1)))%tour; 
        if (Motor.Angle_target<0){Motor.Angle_target=tour+Motor.Angle_target;}    
        Serial.print("Angle = ");Serial.print(encoder_count);Serial.print(" Angle target= ");Serial.print(Motor.Angle_target);
        Serial.print(" encoder shift= ");Serial.println(encoder_Shift);
        //encoder_count_prev=encoder_count;
        //Motor.Ashift=encoder_Shift;
        // if (atoi(ms.GetCapture(captureBufM,1))>round(tour/2)){
        //   rel_count=floor(atoi(ms.GetCapture(captureBufM,1))/(tour/2));
        // }

      }
    


      char resultMS=ms.Match ("(MS)(%+?%-?%d+)(P)(%+?%-?%d+)(;)",0);
      if (resultMS == REGEXP_MATCHED){
        char captureBufMS [8];
        Serial.print("Simple speed control mode, speed=");  
        theta_star=0;
        previous_tstar=0;
        //dt_DR=5E-3;
        speed_roll=atoi(ms.GetCapture (captureBufMS,1));//*dt_DR;//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
        Serial.println(speed_roll);   
        Serial.print("until shift pos= ");  
        Motor.Ashift=atoi(ms.GetCapture (captureBufMS,3));
        Serial.println(Motor.Ashift);   
        //if (Motor.Angle_target<0){Motor.Angle_target=tour+Motor.Angle_target;}    
        //Serial.print("Angle = ");Serial.print(encoder_count);Serial.print(" Angle target= ");Serial.print(Motor.Angle_target);
        //Serial.print(" encoder shift= ");Serial.println(encoder_Shift);
        //encoder_count_prev=encoder_count;
        //Motor.Ashift=encoder_Shift;
        // if (atoi(ms.GetCapture(captureBufM,1))>round(tour/2)){
        //   rel_count=floor(atoi(ms.GetCapture(captureBufM,1))/(tour/2));
        // }

        Motor.State=9;
        previousMillis11 = millis(); 

      }

    char resultF=ms.Match ("(SF)(%+?%-?%d+)(;)",0);// Simple PWM control
    if (resultF == REGEXP_MATCHED){
      char captureBufF [10];     
      Serial.print("Simple PWM control MODE F, PWM=");       
      Motor.PWM=atoi(ms.GetCapture (captureBufF,1));
      Motor.State=7;
      Serial.println(Motor.PWM);
    } 

    char resultFS=ms.Match ("(SFS)(%+?%-?%d+)(;)",0);// Simple PWM control
    if (resultFS == REGEXP_MATCHED){
      char captureBufFS [10];     
      Serial.print("Simple PWM control MODE S, PWM=");       
      Motor.PWM=atoi(ms.GetCapture (captureBufFS,1));
      Motor.State=12;
      Serial.println(Motor.PWM);
    } 

    char resultBr=ms.Match ("(Br)(%+?%-?%d+)(;)",0);// Simple PWM control
    if (resultBr == REGEXP_MATCHED){
      char captureBufBr [10];     
      Serial.print("Brake at PWM =");       
      Motor.PWM=atoi(ms.GetCapture (captureBufBr,1));
      Motor.State=13;
      Serial.println(Motor.PWM);
    } 

    char resultDiffPWM=ms.Match ("(DiffPWM)(%+?%-?%d+)(,)(%+?%-?%d+)(;)",0);// Simple PWM control
    if (resultDiffPWM == REGEXP_MATCHED){
      char captureBufBr [15];     
      Serial.print("Diff PWM =");       
      Motor.PWM=atoi(ms.GetCapture (captureBufBr,1));
      Motor.Brake_val=atoi(ms.GetCapture (captureBufBr,3));
      Motor.State=14; 
      Serial.print(Motor.PWM); Serial.print(',');Serial.println(Motor.Brake_val);
    } 

  }


//////////////////////////////////////////////////////////////////////////

 if (Poke){ 

    unsigned long currentMillis1 = millis();
    if (currentMillis1 - previousMillis1 <= 1000){   //1/this value=frequency at which value is send to broadcast
      //previousMillis1 = currentMillis1;    // Save timestamp
      //Serial.println("POKE");
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(0,0,100);
      tp.DotStar_Show();  
    }
    else {tp.DotStar_SetPower(false);Poke=0;} 

  }
 
  // unsigned long currentMillis2 = millis();
  // if (currentMillis2 - previousMillis2 >= Res_speed){   //PID computed value updated every 3ms
  //   previousMillis2 = currentMillis2;    // S
  //   dtheta=encoder_count-previous_encoder_count;
  //   if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  //   else if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  //   else {Motor.Speed=dtheta;}
  //   //Motor.Speed=dtheta;
  //   previous_encoder_count=encoder_count;
  //   //Serial.print("Motor speed = ");Serial.println(Motor.Speed);
  // }
  
  unsigned long currentMillis2 = millis();
  dtheta=encoder_count-previous_encoder_count;
  if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  else if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  else {Motor.Speed=dtheta;}
  previous_encoder_count=encoder_count;
  dt=currentMillis2-previousMillis2;
  previousMillis2 = currentMillis2;

 
 if (Motor.State==0){ // "soft" mode
    //tp.DotStar_SetPower(false);  
    MotorOFF();
    encoder_count_prev=encoder_count;
    Motor.Angle_target=encoder_count_prev;
  }  

  if (Motor.State==1){  //"stiff" mode
       

    if (tour-Motor.Angle_target>round(tour/2)){Motor.Angle_target=tour+Motor.Angle_target;}
    if (Motor.Angle_target-encoder_count>round(tour/2)){encoder_count=tour+encoder_count;}
  
    unsigned long currentMillis4 = millis();
    if (currentMillis4 - previousMillis4 >= 2){   //PID computed value updated every 3ms
      previousMillis4 = currentMillis4;    // Save timestamp                      
      
      // if (rel_count>0){
      //   if (encoder_count==Motor.Angle_target)
      //   Motor.Angle_target=; // The "goal" the PID controller tries to "reach", 
      // }   
      //}

      pidcontroller.setpoint(Motor.Angle_target);

      Motor.PWM = pidcontroller.compute(encoder_count); 
      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,20);}
      else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),20);}
     
      //motor(Motor.PWM); //not working

      if (encoder_count>tour){encoder_count=encoder_count-tour;}
    }    
  } 


/////////////////////////////////////////////////////////////////////////////////////////////
  if (Motor.State==2){ // "spring" mode
      //Serial.println("Inside mode spring");
      

      // dtheta=encoder_count-previous_encoder_count;
      // if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      // else if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      // else {Motor.Speed=dtheta;}
      // previous_encoder_count=encoder_count;

      theta_star=theta_star+Motor.Speed;


    if (test<100){ //initial kick
      pidcontroller.setpoint(theta_eq+theta_0); // The "goal" the PID controller tries to "reach", 
      Motor.PWM = pidcontroller.compute(encoder_count); 
      test=test+1;
    }
    else {

      
      // if  ((theta_eq-theta_0>=1) & (theta_eq+theta_0<tour)){
      //   theta_star=encoder_count-theta_eq;
      //   Motor.Speed=dtheta;
      // } 
      // else {
      //   if (theta_eq-theta_0<1){
      //     if (encoder_count>theta_eq+(3*theta_0)){theta_star=encoder_count-theta_eq-tour;}else{theta_star=encoder_count-theta_eq;}
      // }
      //   if (theta_eq+theta_0>tour){
      //     if (encoder_count<theta_eq-(3*theta_0)){theta_star=tour-theta_eq+encoder_count;}else{theta_star=encoder_count-theta_eq;}
      //   }
      // }

      // else if (theta_eq-theta_0<1){
      //   if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      //   if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      //   if (state){theta_star=encoder_count-theta_eq-tour;}
      //     else{theta_star=encoder_count-theta_eq;Motor.Speed=dtheta;}
      // }
      // else if (theta_eq+theta_0>tour){
      //   if (encoder_count<theta_eq-theta_0){theta_star=tour-theta_eq+encoder_count;}else{theta_star=encoder_count-theta_eq;}
      // }

      Motor.PWM=((-1)*k*(theta_star)/1000)+(bias*Motor.Speed/100);
    }

    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      //Motor.PWM=Motor.PWM+bias;
      motor_ccw(Motor.PWM,20);}
    else{ // else we move it in a counter clockwise direction
      //Motor.PWM=Motor.PWM-bias;
      motor_cw(abs(Motor.PWM),20);}

  }

  if (Motor.State==3){ // "cogue torque + friction calibration" mode
   unsigned long currentMillis6 = millis();
   if (currentMillis6 - previousMillis6 >= Cal_time){//4){   //1/this value=frequency at which messages are sent outward
    previousMillis6 = currentMillis6; 
    incr_cal=incr_cal+Cal_interval;  
    if (incr_cal<256){
      Motor.PWM=incr_cal;
      motor_cw(abs(Motor.PWM),0);}
    else{
      Motor.State=0;
      incr_cal=(-1)*Cal_interval;} 
   }
  } 

  if (Motor.State==10){ // "cogue torque + friction calibration" mode slow decay
   unsigned long currentMillis12 = millis();
   if (currentMillis12 - previousMillis12 >= Cal_time){//4){   //1/this value=frequency at which messages are sent outward
    previousMillis12 = currentMillis12; 
    incr_cal=incr_cal+Cal_interval;  
    if (incr_cal<256){
      Motor.PWM=incr_cal;
      motor_cw_s(abs(Motor.PWM),0);}
    else{
      Motor.State=0;
      incr_cal=(-1)*Cal_interval;} 
   }
  } 

  if (Motor.State==11){ // "cogue torque + friction calibration" mode slow decay
   unsigned long currentMillis13 = millis();
   if (currentMillis13 - previousMillis13 >= Cal_time){//4){   //1/this value=frequency at which messages are sent outward
    previousMillis13 = currentMillis13; 
    incr_cal=incr_cal+Cal_interval;  
    if (incr_cal<256){
      Motor.PWM=incr_cal;
      motor_cw_s2(abs(Motor.PWM),0);}
    else{
      Motor.State=0;
      incr_cal=(-1)*Cal_interval;} 
   }
  } 


//////////////////////////////////////////////////////
  if (Motor.State==4){ // "Handcheck" mode
    
    theta_star=theta_star+Motor.Speed;
    
    if (sol_mode==1){ //master mode

      unsigned long currentMillis8 = millis();
      if (currentMillis8 - previousMillis8 >= (int)refresh){//4){   //1/this value=frequency at which messages are sent outward
        previousMillis8 = currentMillis8; 
        sol_pulse=M_PI*1000/(float)(refresh*Sample_Hand);
        func_pos=sol_amp*sin((float)(time_count*sol_pulse)/1000);
        time_count=time_count+round(sol_period/Sample_Hand);
  
        if (time_count<=(int)refresh*Sample_Hand){pidcontroller.setpoint(sol_coef0*func_pos);}//Serial.println(func_pos);}
        else {pidcontroller.setpoint(0);}//Serial.println(0);}
              
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckS[10];
        memset(bufcheckS, 0, 10); 
        sprintf(bufcheckS,"M%i;",theta_star);       
        Udp.print(bufcheckS);
        Udp.endPacket();
      
      }

      //Serial.println(encoder_count);
      //Serial.println(theta_star);
      //Serial.println(Motor.PWM);
      Motor.PWM = pidcontroller.compute(theta_star);
      //Serial.println(func_pos);

      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
        motor_ccw(Motor.PWM,20);}
      else{ // else we move it in a counter clockwise direction
        motor_cw(abs(Motor.PWM),20);}


      unsigned long currentMillis7 = millis();    
      if (currentMillis7- previousMillis7 >= sol_speed_g){
      
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheck[7]={'O',';'};  
        Udp.print(bufcheck);
        Udp.endPacket();
        tp.DotStar_SetPower(false); 
      }
          
      
      if ((time_count>(refresh*Sample_Hand)) && (currentMillis7- previousMillis7 >= sol_speed_g)){  
        Motor.State=1;
        time_count=0; 
      } 
    
  }

    if (sol_mode==2){// slave mode
 
      pidcontroller.setpoint(sol_coef[Neighbor_count-1]*Master_dtheta);

      // if (Neighbor_count<sol_n){
      //   Udp.beginPacket(udpAddressN, localPort); 
      //   char bufcheckS[15];
      //   memset(bufcheckS, 0, 15); 
      //   sprintf(bufcheckS,"M%i/%i/%i;",Master_Address, Master_dtheta,Neighbor_count);       
      //   //Serial.println(bufcheckS);
      //   Udp.print(bufcheckS);
      //   Udp.endPacket();
      // }

      Serial.print(Master_dtheta);Serial.print(' ');
      Serial.println(Neighbor_count);
      Motor.PWM = pidcontroller.compute(theta_star);

      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
        motor_ccw(Motor.PWM,20);}
      else{ // else we move it in a counter clockwise direction
        motor_cw(abs(Motor.PWM),20);}
        
    }
       
  } 
///////////////////////////////////////////////////////////////////////////////

 if (Motor.State==5){ // "Hand Roll" mode
 
  theta_star=theta_star+Motor.Speed;

  if (Motor.Address==AddressLead){ //lead mode
    
    
    //pidcontroller.setpoint(0);

    unsigned long currentMillis7 = millis();    
    if (currentMillis7- previousMillis7 >= 10){
        pidcontroller.setpoint(speed_roll);
        speed_roll_meas=theta_star-previous_tstar;
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckS[10];
        memset(bufcheckS, 0, 10); 
        sprintf(bufcheckS,"MR%i;",theta_star);       
        Udp.print(bufcheckS);
        Udp.endPacket();
        //Serial.print("Data sent V=");Serial.println(speed_roll_meas);    
        //tp.DotStar_SetPower(false); 
        Motor.PWM = pidcontroller.compute(speed_roll_meas);
        previous_tstar=theta_star;
      }


  } else{  //slave mode

    pidcontroller.setpoint(Master_dtheta);
    Motor.PWM = pidcontroller.compute(theta_star);

    }

    if (Neighbor_address_int==0){Motor.PWM =0;}
 
  if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
    motor_ccw(Motor.PWM,20);}
  else{ // else we move it in a counter clockwise direction
    motor_cw(abs(Motor.PWM),20);}
 }



  if (Motor.State==6){ // "Direct Roll" mode
  
    theta_star=theta_star+Motor.Speed;    

    unsigned long currentMillis9 = millis();    
    if (currentMillis9- previousMillis9 >= (int)1000*dt_DR){
    //if (currentMillis9- previousMillis9 >= speed_roll){
        pidcontroller.setpoint(speed_roll);
        //pidcontroller.setpoint(100);
        previousMillis9 = currentMillis9; 
        speed_roll_meas=(theta_star-previous_tstar)*dt_DR;
        Motor.PWM = pidcontroller.compute(speed_roll_meas);
        previous_tstar=theta_star;
      }
  
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,20);}
    else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),20);}
  }

 
  if (Motor.State==7){ // "Direct Roll" mode
    
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,0);}
    else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),0);}
  }

  if (Motor.State==12){ // "Direct Roll" mode
    
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw_s(Motor.PWM,0);}
    else{ // else we move it in a counter clockwise direction
      motor_cw_s(abs(Motor.PWM),0);}
  }


  if (Motor.State==8){ // "Force soliton lead" mode

    unsigned long currentMillis10 = millis();    
    if (currentMillis10- previousMillis10 >= sol_speed_g){
    
      Udp.beginPacket(udpAddressN, localPort); 
      char bufcheck[7]={'O','F',';'};  
      Udp.print(bufcheck);
      Udp.endPacket();
      tp.DotStar_SetPower(false); 
      Motor.PWM=0;
      Serial.println("Neighbor Master CHECK sent");
      Motor.State=0;
    }
    //Serial.println(currentMillis10- previousMillis10);


    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,20);}
    else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),20);}
  }

  if (Motor.State==9){ // "Simple speed controled" mode
   
   theta_star=theta_star+Motor.Speed;    

    unsigned long currentMillis11 = millis();    
    if (currentMillis11- previousMillis11 >= 20){//(int)1000*dt_DR){
    //if (currentMillis9- previousMillis9 >= speed_roll){
        pidcontroller.setpoint(speed_roll);
        //pidcontroller.setpoint(100);
        previousMillis11 = currentMillis11; 
        speed_roll_meas=(theta_star-previous_tstar)*dt_DR;
        Motor.PWM = pidcontroller.compute(speed_roll_meas);
        previous_tstar=theta_star;
        //Serial.println(theta_star);   
      }

    if (abs(theta_star)>=Motor.Ashift){
      Serial.println("Rotor reached target displacement");   
      Motor.Angle_target=encoder_count;
      Motor.State=0;
    }  
  
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,20);}
    else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),20);}
  }

   if (Motor.State==13){
     MotorBRAKE(Motor.PWM);
   }

  if (Motor.State==14){
    // if (Motor.PWM>0){MotorDiffPWM_cw(Motor.PWM,Motor.Brake_val);}
    // else{MotorDiffPWM_ccw(Motor.PWM,Motor.Brake_val);}
    MotorDiffPWM(Motor.PWM,Motor.Brake_val);
   }

  ////////////////////////Data format and send
  unsigned long currentMillis5 = millis();
  if (currentMillis5 - previousMillis5 >= 10){//4){   //1/this value=frequency at which messages are sent outward
    previousMillis5 = currentMillis5;    // Save timestamp   
    // Serial.println(currentMillis5);
    // Motor.Angle=map(encoder_count,round(tour/2),tour+round(tour/2),0,1023);
    // Motor.Angle=(Motor.Angle+512)%1023;
    Motor.Angle=encoder_count;
    
    // Serial.print(0);Serial.print(" ");
    // Serial.print(tour);Serial.print(" ");
    // Serial.print(Motor.Speed*100);Serial.print(" ");
    // Serial.print(theta_star);Serial.print(" ");
    // Serial.println(Motor.Angle);

    //ThetaG=atan2((double)accel.acceleration.y,(double)accel.acceleration.x)-(M_PI/4);
    //if (ThetaG<=-M_PI){ThetaG=M_PI/4-abs(ThetaG+M_PI)+(3*M_PI/4);} //rotation of pi/4 to take the plug up as 0 reference
    //Serial.println(ThetaG);
  
    // create JSON object 
    // Declare a buffer to hold the result
    char output[210];//[192];// recomended size. can be decreased down to 144 max. https://arduinojson.org/v6/assistant/
    StaticJsonDocument<210> motion;

// //current sensor
    shuntvoltage = ina219.getShuntVoltage_mV();
    busvoltage = ina219.getBusVoltage_V();
    current_mA = ina219.getCurrent_mA();
    //power_mW = ina219.getPower_mW();
    //loadvoltage = busvoltage + (shuntvoltage / 1000);
  
  // Serial.print("Bus Voltage:   "); Serial.print(busvoltage); Serial.println(" V");
  // Serial.print("Shunt Voltage: "); Serial.print(shuntvoltage); Serial.println(" mV");
  // Serial.print("Load Voltage:  "); Serial.print(loadvoltage); Serial.println(" V");
  // Serial.print("Current:       "); Serial.print(current_mA); Serial.println(" mA");
  // Serial.print("Power:         "); Serial.print(power_mW); Serial.println(" mW");
  // Serial.println("");
  // //////////////////////////////////////////////////////



    // Compute the length of the minified JSON document
    //      int len1=measureJson(motion);
    //      Serial.print("JSON document size:");Serial.println(len1);
    motion["d"] = Motor.Address;
    motion["t"] = millis();
    motion["A"] = Motor.Angle;    
    //motion["x"] = accel.acceleration.x;
    //motion["y"] = accel.acceleration.y;
    //motion["z"] = accel.acceleration.z;
    //motion["u"] = gyro.gyro.x;
    //motion["v"] = gyro.gyro.y;
    //motion["w"] = gyro.gyro.z;
    motion["T"] = Motor.PWM;
    motion["S"] = Motor.State;
    motion["B"] = ((tp.GetBatteryVoltage()-3.5)/0.70)*100;

    char buf[20];
    sprintf(buf,udpAddress);
    motion["ipo"]=buf;
    //Serial.println(buf);
    motion["I"]=current_mA;
    //motion["Ul"]=loadvoltage;
    motion["Ub"]=busvoltage;
    motion["Us"]=shuntvoltage;
    //Serial.println(lsm6dsox.rawAccX);
    
    serializeJson(motion,output);
    //serializeJson(motion,Serial);
    //Serial.println();
    //Serial.print(" ");Serial.println(micros());
    
    //char buffer1[128];
    //memset(buffer1, 0, 6);   
    Udp.beginPacket(udpAddress, outPort);   
    //itoa(Motor.Angle, buffer1,10);
    //Udp.print("A");
    Udp.print(output);
    Udp.endPacket();
    // Serial.print(" ");Serial.println(micros());
    //Serial.println(Motor.Angle);
    //Serial.print(currentMillis5); Serial.print(" "); Serial.println(udpAddress);
    }///loop current millis
//
//    unsigned long currentMillis6 = millis();
//    if (currentMillis6 - previousMillis6 >= 10000){   //PID computed value updated every 3ms
//        previousMillis6 = currentMillis6;    // Save timestamp   
//    
//        char bufBat[8];
//        memset(bufBat, 0, 8);
//        bufBat.add(((tp.GetBatteryVoltage()-3.5)/0.70)*100);
//        Udp.beginPacket(udpAddress, outPort);   
//        Udp.print(bufBat);
//        Udp.endPacket();   
//    }
//  //Serial.print(" ");Serial.println(millis());

}   //end void loop