/*Granulobot UDP Firmware V14 
 * Encoder position measurement and conversion in angle and angular velocity
 * Magnet's magnetic field measurement
 * accel + gyr measurement
 * PWM Control of N20 geared motors
 * 2 ways UDP wifi communication with broadcasting address
 * PID on position encoder  https://github.com/DonnyCraft1/PIDArduino
 * https://circuitdigest.com/microcontroller-projects/arduino-based-encoder-motor-using-pid-controller
 *  OTA wireless firmware upload: https://randomnerdtutorials.com/esp32-over-the-air-ota-programming/

*      autoselect particule address from database defined in header {IP address number(last digits),paticule adress number}
* New on V16:
*      New general form of voltage control function 
*
*components controlled by the firmware:
*
*accel+gyro: LSM6DSOX 
*magnetic sensor: Tlv493d (+-150mT)
*magnetic encoder: Pololu
*Motor driver: DRV8833
*Microcontroller: ESP32
*StepUp motor: TPS61178 (with Enable Pin)
*
*OpenStageControl ressources:
*https://openstagecontrol.ammd.net/docs/custom-module/custom-module/
*
*by Baudouin Saintyves
November 15th 2022
*
* Data generated by the robot:
* "{"A":1,"t":97768,"d":5,"x":0.052642,"y":-0.095713,"z":9.818948,"u":0.001222,"v":0.00733,"w":-0.006109}"
*
* for .bin versioning, see https://stackoverflow.com/questions/56923895/auto-increment-build-number-using-platformio
*/

///////Include Local///////////////
//#include "Wifi_Home.h"
#include "Wifi_NET.h"
//#include "Wifi_iphone.h"
//#include "Wifi_TP_1.h"
//#include "Wifi_Marc.h"

//IP address of neighbor for handcheck soliton
char udpAddressN[15];

#include "Granulobot_pin_v1_2.h"
//#include "Granulobot_pin_v1_1.h"
//////////////////////////////////

//////////////////////////////
char *ADDRESS_DATA_BASE[] = {  //
  "3E:A8",//1
  "4D:B4",//2
  "4D:94",//3
  "4D:A4",//4
  "4D:84",//5
  "4D:88",//6
  "4D:A8",//7
  "3E:B8",//8
  "4D:D4",//9
  "4D:C4",//10
  "4E:B8",//11
  "4D:C8",//12
  "4D:98",//13
  "4D:B8",//14 
  "4E:24",//15
  //add new particule here
  "00:00"};

//char *IPparts[sizeof(ADDRESS_DATA_BASE)/sizeof(char *)] ;
# define M_PI           3.14159265358979323846  /* pi */

/////MOTOR PARAMETERS//////////
//choose here the motor's gear ratio
const int ratio=379;//986.41;//tour=986*12=11832
//180deg=5916
//90deg=2958
//45deg=1479
//put here the measured motor constants
const float K_t_p=5.8e-3; 
const float K_t_n=1.3e-3; 
const float Res=9.6; 
const float K_e=2.65e-3;
const float prefactor_p=Res/(ratio*K_t_p);
const float prefactor_n=Res/(ratio*K_t_n);
const float eta_0_p=ratio*ratio*K_e*K_t_p/Res;
const float eta_0_n=ratio*ratio*K_e*K_t_n/Res;
const float prefactor_2=1/(ratio*K_e);
const int tour=ratio*12;

const float H1=255/6;
const float H2=H1*(2*M_PI/tour)*prefactor_p;
const float H3=H2*eta_0_p;

//choose here the motor's position PID parameters
#define __Kp 100//200//260 // Proportional constant
#define __Ki 0//2 //2.7 Integral Constant
#define __Kd 5000//2000//2000 // Derivative Constant

//choose here the motor's speed PID parameters
#define __Kps 400//260 // Proportional constant
#define __Kis 0 //2.7 Integral Constant
#define __Kds 4000//2000 // Derivative Constant

//choose here motor's PWM frequency
#define FREQ 25
////////////////////////////////////
////////////////////////////////////


////////////////////////////////////
/////EXTERNAL LIBRARIES//////////////////////

 //Arduino
#include <Arduino.h>

  //Wifi
#include <WiFi.h>
#include <WiFiUdp.h>
#include <ESPmDNS.h>
#include <ArduinoOTA.h> //library for Over The Air programming
#include <math.h>
//#include <tgmath.h>
//#include <stdio.h>

  //sensors
#include <Adafruit_Sensor.h>
#include <Adafruit_LSM6DSOX.h>//accel+gyro
#include <Adafruit_LSM6DS.h>//accel+gyro
#include <Tlv493d.h>//magnetic field sensor
#include <Wire.h>
#include <Adafruit_INA219.h>//current sensor


  //packet format and parsing for serial com
#include <Regexp.h>
#include <ArduinoJson.h> // tuto https://arduinojson.org/v6/doc/serialization/

  //TinyPico Helper Library
#include <TinyPICO.h>

// //OSC library     https://github.com/CNMAT/OSC
#include <OSCMessage.h> 
#include <OSCBundle.h>
#include <OSCData.h>

  //PID library
#include <PIDController.h> // https://github.com/DonnyCraft1/PIDArduino

  //filter library
//#include <MegunoLink.h>
//#include <Filter.h>
#include "SingleEMAFilterLib.h"

////particule address number
//int ADDRESS_NUM;

//counter for poke function
int CountPoke=0;

 //Timers
unsigned long previousMillis1 = 0; // store previous millis readout (for PID)
unsigned long previousMillis2 = 0; // store previous millis readout (to send motor.angle)
unsigned long previousMillis3 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis4 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis5 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis6 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis7 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis8 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis9 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis10 = 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis11= 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis12= 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis13= 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis14= 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis15= 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis16= 0; // store previous millis readout (to send Bat level)
unsigned long previousMillis17= 0; // store previous millis readout (to send Bat level)

unsigned long time_wave_0=0;
unsigned long time_wave=0;

//int counter=0;
//const int buffer_size=1000;
//float buffer_S[buffer_size];
//float buffer_time[buffer_size];
float Speed_raw=0;
//int j=0;
float current_avg=0.0;
float current_avg_double=0.0;
float DEMA_avg=0.0;

float last_avg=0.0;
float last_avg_double=0.0;

float alpha_EMA=0.07;

float PWM_raw=0;

float PWM_Speed_raw=0;
//int j=0;
float PWM_current_avg=0.0;
float PWM_current_avg_double=0.0;
float PWM_DEMA_avg=0.0;

float PWM_last_avg=0.0;
float PWM_last_avg_double=0.0;

//calibration time = time between two speed increment
unsigned long Cal_time=1000;
const int Cal_interval=5;//jump between 2 PWM value in Cal

//COMPLIMENTARY FILTER PARAM. LOWERING PARAM=more weight to linear accel= less good in dynamical
float alpha = 0.98;

//general form parameters
float Ub=0;
float U0=0;
float U=0;
float A=0;
float G=0;
float Amp=0;
float phi=0;
float period_wave=0.1;
float pulsation=0;
int8_t signOfX =0;
int RandNumber=0;
bool randomize=false;
int timeRand=0;


//Encoder
volatile int encoder_count=0;
int encoder_count_prev=0;
int encoder_start;
//int prev_count=0;
volatile bool CW;
volatile bool Soft;
const int Res_speed=4;//in ms
int prev_pos=0;
long int speed_tick;
float speed_rad;
int angle_tick=0;
float angle_rad=0;
int speed_target=0;
int direct=0;
int previous=0;
int direct_rec=0;
int k=0;//spring potential
int theta_0=0;
int theta_eq=0;
int theta_star=0;
int bias=0;
int previous_encoder_count=0;
int dtheta=0;
bool state=false;
int dt=0;
int incr_cal;
int sol_amp=0;
//int sol_speed_p=0;
int sol_speed_g=0; //in millisecond, time between two handchecks => equivalent of soliton's group speed
float sol_pulse=0.0;
int sol_period=0;
int Neighbor_address_int=0;
int Part_Sequence_int[sizeof(ADDRESS_DATA_BASE)/sizeof(char *)];
float func_pos=0.0;
int time_count=0;
int Sample_Hand=50;
float refresh=0;
int sol_mode=0;
int Master_dtheta=0;
int Master_Address=0;
int Neighbor_count=0;
int sol_n=4;
int sol_coef[4]={-1,1,-1,1};
int sol_nF=5;
int sol_coefF[5]={0,0,0,0,0};
int sol_coef0=1;
float speed_roll=0;
int AddressLead=0;
int previous_tstar=0;
float speed_roll_meas=0;
int Move_amp=0;
float dt_DR=0;
int sol_PWM=0;
int yield_PWM=0;
float range_dtheta=0;
int range_PWM=0;
bool range_Init=false;
int Angle_field_0=0;
const int buffersize_angle_field = 10;
//int Angle_field[buffersize_angle_field];
float Angle_field;
int Angle_field_target=0;
int readIndex=0;
int total=0;
int average=0;
int g0x=0;
int g0y=0;
float tilt_0=0.0;
float tilt=0.0;
//float tilt_02=0.0;
//float tilt_2=0.0;
int gx=0;
int gy=0;
float d_tilt_1=0.0;
float previous_tilt=0.0;
bool state_2=false;
float dalpha_t=0;
float dalpha=0;
float tilt_star=0.0;
// float gyro_angle_x=0.0;
// float gyro_angle_y=0.0;
int previous_t=0;
int t_0=0;
float previous_x_angle=0.0;
float previous_y_angle=0.0;
float previous_x_gyro_angle=0.0;
float previous_y_gyro_angle=0.0;
float angle_x=0.0;
float angle_y=0.0;

//int rel_count=0; //relative displacement in mode 9 = simple speed control

// //current sensor  if need current sensor, uncomment line 320,822,2043,2081
// float shuntvoltage = 0;
// float busvoltage = 0;
// float current_mA = 0;
// float loadvoltage = 0;
// // float power_mW = 0;




unsigned int angle_target = 0; // stores the incoming serial value. Max value is 65535
char incomingByte; // parses and stores each individual character one by one
//int motor_pwm_value = 255; // after PID computation data is stored in this variable.


struct Button {
  const uint8_t PIN;
  //uint32_t encoder_count;
  bool detect;
};

Button MA = {ENCODER_A, false};//Encoder OUT A
Button MB = {ENCODER_B, false};//Encoder OUT B


//Motor control

//global variables
bool MoveStop=false;
// setting PWM properties
//const int freq = FREQ;
int freq = FREQ;
const int MotChannel1 = 1;
const int MotChannel2 = 2;
const int resolution = 8;

//for PID
//int motor_pwm_value = 0; // after PID computation data is stored in this variable.
unsigned int integerValue = 0;

bool Poke=false;

//for OSC Com
typedef struct Message {
  int Address;
  int Mode;
  int Torque;
  int Max_Torque;
  int Speed;
  int Speed_target;
  int Vshift;
  int Ashift;
  int State;
  //int Displacement;
  int Angle;
  int Angle_target;
  bool Direction;//true=CW or false=CCW
  int PWM; // after PID computation data is stored in this variable.
  int Brake_val;
  bool Minus_State;
  bool Plus_State;
} Message;

int P=0;
int angle_interval;
int test_prev;
int test=0;
int encoder_Shift=0;
int encoder_count_2=0;
int encoder_count_target=0;

float ThetaG;

Message Motor;

SingleEMAFilter<float> singleEMAFilter(0.6);

///deep sleep
//#define BUTTON_PIN_BITMASK 0x200000000 // 2^33 in hex / for deep sleep on pin 33 with ext1
RTC_DATA_ATTR int bootCount = 0; // for deep sleep
/////////////////////////////////////

//INITIALISE
 //Initialise sensors
    // LSM6DSOX Object
Adafruit_LSM6DSOX lsm6dsox;
    // Tlv493d Object
Tlv493d Tlv493dMagnetic3DSensor = Tlv493d();

//     // INA219 current sensor object 
// Adafruit_INA219 ina219;

    //create PID object
PIDController pidcontroller;
PIDController pidcontroller_speed;

//create UDP instance
WiFiUDP Udp;
OSCErrorCode error;

// Initialise TinyPICO library
TinyPICO tp = TinyPICO();

//const int capacity=JSON_ARRAY_SIZE(3)+JSON_OBJECT_SIZE(1)+2*JSON_OBJECT_SIZE(3);
const int capacity = JSON_OBJECT_SIZE(9);
StaticJsonDocument<capacity> motion;

////////////////////////////////////
/////FUNCTIONS//////////////////////
void MotorOFF(){
  ledcWrite(MotChannel1, 0);
  ledcWrite(MotChannel2, 0);
  }

void MotorBRAKE(int brake_val){
  ledcWrite(MotChannel1, brake_val);
  ledcWrite(MotChannel2, brake_val);
  }

void MotorDiffPWM(int a,int b){
  ledcWrite(MotChannel1, a);
  ledcWrite(MotChannel2, b);
}
  

void MotorDiffPWM_cw(int power, int Brake){
  ledcWrite(MotChannel1, abs(Brake));
  ledcWrite(MotChannel2, abs(Brake)-abs(power));
  } 

void MotorDiffPWM_ccw(int power, int Brake){
  ledcWrite(MotChannel1, abs(Brake)-abs(power));
  ledcWrite(MotChannel2, abs(Brake));
  }


void motor(int power) {   //fast decay
  if (abs(power) > 20) {
    if (power > 0) {
      //Serial.println("Motor cw");
      ledcWrite(MotChannel1, abs(power));
      ledcWrite(MotChannel2, 0);     
      } 
    else{
      //Serial.println("Motor ccw");
      ledcWrite(MotChannel1, 0);
      ledcWrite(MotChannel2, power);
      }
  } 
  else{
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}

void motor_cw(int power,int tresh) {  //fast decay
  if (power > tresh) {
    //Serial.println("Motor cw");
    ledcWrite(MotChannel1, power);
    ledcWrite(MotChannel2, 0);
  }
  else {
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}
void motor_ccw(int power,int tresh) { //fast decay
  if (power > tresh) {
    //Serial.println("Motor ccw");
    ledcWrite(MotChannel2, power);
    ledcWrite(MotChannel1, 0);
  }
  else {
    ledcWrite(MotChannel1, 0);
    ledcWrite(MotChannel2, 0);
  }
}

void motor_cw_s(int power,int tresh) {  //slow decay
  if (power > tresh) {
    //Serial.println("Motor cw");
    ledcWrite(MotChannel1, 255);
    ledcWrite(MotChannel2, 255-power);
  }
  else {
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 255);
    ledcWrite(MotChannel2, 255);
  }
}
void motor_ccw_s(int power,int tresh) {  //slow decay
  if (power > tresh) {
    //Serial.println("Motor ccw");
    ledcWrite(MotChannel2, 255);
    ledcWrite(MotChannel1, 255-power);
  }
  else {
    ledcWrite(MotChannel1, 255);
    ledcWrite(MotChannel2, 255);
  }
}

void motor_cw_s2(int power,int tresh) {  //slow decay
  if (power > tresh) {
    //Serial.println("Motor cw");
    ledcWrite(MotChannel1, 128+round(power/2));
    ledcWrite(MotChannel2, 128-round(power/2));
  }
  else {
    // both of the pins are set to low    
    ledcWrite(MotChannel1, 128);
    ledcWrite(MotChannel2, 128);
  }
}

void CONTROL_SPEED(PIDController PID, int Speed){     
    //Serial.println("control speed");
    int PWM=PID.compute(Speed);
    Serial.print("control speed, PWM= ");Serial.println(PWM);
    if (PWM > 0) // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(PWM,20);
    else // else we move it in a counter clockwise direction
      motor_cw(abs(PWM),20);  
    } 


void displaySensorDetailsISM(void) {
  Serial.print("Accelerometer range set to: ");
  switch (lsm6dsox.getAccelRange()) {
  case LSM6DS_ACCEL_RANGE_2_G:
    Serial.println("+-2G");
    break;
  case LSM6DS_ACCEL_RANGE_4_G:
    Serial.println("+-4G");
    break;
  case LSM6DS_ACCEL_RANGE_8_G:
    Serial.println("+-8G");
    break;
  case LSM6DS_ACCEL_RANGE_16_G:
    Serial.println("+-16G");
    break;
  }
  
  Serial.print("Gyro range set to: ");
  switch (lsm6dsox.getGyroRange()) {
  case LSM6DS_GYRO_RANGE_125_DPS:
    Serial.println("125 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_250_DPS:
    Serial.println("250 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_500_DPS:
    Serial.println("500 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_1000_DPS:
    Serial.println("1000 degrees/s");
    break;
  case LSM6DS_GYRO_RANGE_2000_DPS:
    Serial.println("2000 degrees/s");
    break;
  case ISM330DHCX_GYRO_RANGE_4000_DPS:
    Serial.println("4000 degrees/s");
    break;
  }

  Serial.print("Accelerometer data rate set to: ");
  switch (lsm6dsox.getAccelDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }

  Serial.print("Gyro data rate set to: ");
  switch (lsm6dsox.getGyroDataRate()) {
  case LSM6DS_RATE_SHUTDOWN:
    Serial.println("0 Hz");
    break;
  case LSM6DS_RATE_12_5_HZ:
    Serial.println("12.5 Hz");
    break;
  case LSM6DS_RATE_26_HZ:
    Serial.println("26 Hz");
    break;
  case LSM6DS_RATE_52_HZ:
    Serial.println("52 Hz");
    break;
  case LSM6DS_RATE_104_HZ:
    Serial.println("104 Hz");
    break;
  case LSM6DS_RATE_208_HZ:
    Serial.println("208 Hz");
    break;
  case LSM6DS_RATE_416_HZ:
    Serial.println("416 Hz");
    break;
  case LSM6DS_RATE_833_HZ:
    Serial.println("833 Hz");
    break;
  case LSM6DS_RATE_1_66K_HZ:
    Serial.println("1.66 KHz");
    break;
  case LSM6DS_RATE_3_33K_HZ:
    Serial.println("3.33 KHz");
    break;
  case LSM6DS_RATE_6_66K_HZ:
    Serial.println("6.66 KHz");
    break;
  }
}
/*
Method to print the reason by which ESP32
has been awaken from sleep
*/
void print_wakeup_reason(){
  esp_sleep_wakeup_cause_t wakeup_reason;

  wakeup_reason = esp_sleep_get_wakeup_cause();

  switch(wakeup_reason)
  {
    case ESP_SLEEP_WAKEUP_EXT0 : Serial.println("Wakeup caused by external signal using RTC_IO"); break;
    case ESP_SLEEP_WAKEUP_EXT1 : Serial.println("Wakeup caused by external signal using RTC_CNTL"); break;
    case ESP_SLEEP_WAKEUP_TIMER : Serial.println("Wakeup caused by timer"); break;
    case ESP_SLEEP_WAKEUP_TOUCHPAD : Serial.println("Wakeup caused by touchpad"); break;
    case ESP_SLEEP_WAKEUP_ULP : Serial.println("Wakeup caused by ULP program"); break;
    default : Serial.printf("Wakeup was not caused by deep sleep: %d\n",wakeup_reason); break;
  }
}


/////////////////////////////////////
//attach interrupt functions for encoder
void IRAM_ATTR isr_A() {
if (digitalRead(MA.PIN) == HIGH){
    if (digitalRead(MB.PIN) == HIGH){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
else{ if (digitalRead(MB.PIN) == LOW){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }       
MA.detect = true;
}


void IRAM_ATTR isr_B() {
if (digitalRead(MB.PIN) == HIGH){
    if (digitalRead(MA.PIN) == LOW){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
else{
    if (digitalRead(MA.PIN) == HIGH){encoder_count++;CW=true;}
    else {encoder_count--;CW=false;}
    }
MB.detect = true;
}
///////////////////////////////////////////////
////////////////////////////////////////////////


/////rewrite this from parser in HandInit
void ParseStr(String str, String *Part_Sequence_vec){
  int StringCount = 0;
  // Split the string into substrings
  while (str.length() > 0)
  {
    int index = str.indexOf(' ');
    if (index == -1) // No space found
    {
      Part_Sequence_vec[StringCount++] = str;
      break;
    }
    else
    {
      Part_Sequence_vec[StringCount++] = str.substring(0, index);
      str = str.substring(index+1);
    }
  }
}

// template <uint8_t K, class uint_t = uint16_t>
// class EMA {
//   public:
//     /// Update the filter with the given input and return the filtered output.
//     uint_t operator()(uint_t input) {
//         state += input;
//         uint_t output = (state + half) >> K;
//         state -= output;
//         return output;
//     }

//     static_assert(
//         uint_t(0) < uint_t(-1),  // Check that `uint_t` is an unsigned type
//         "The `uint_t` type should be an unsigned integer, otherwise, "
//         "the division using bit shifts is invalid.");

//     /// Fixed point representation of one half, used for rounding.
//     constexpr static uint_t half = 1 << (K - 1);

//   private:
//     uint_t state = 0;
// };

// const unsigned long interval = 10000; // 10000 Âµs = 100 Hz



void setup(){

  Wire.setClock(400000); //test 
  
  // log_d("Total heap: %d", ESP.getHeapSize());//core debug level to "verbose"
  // log_d("Free heap: %d", ESP.getFreeHeap());
  // log_d("Total PSRAM: %d", ESP.getPsramSize());
  // log_d("Free PSRAM: %d", ESP.getFreePsram());
  
  Serial.begin(115200);
  Serial.println("RESET");
  Serial.println("Firmware Granulobot UDP V16");


//check General form prefactors:
Serial.print("prefactor_p= ");Serial.print(prefactor_p);
Serial.print(" prefactor_n= ");Serial.print(prefactor_n);
Serial.print(" eta_0_p= ");Serial.print(eta_0_p);
Serial.print(" eta_0_n= ");Serial.print(eta_0_n);
Serial.print(" 1/(beta K_e)= "); Serial.println(prefactor_2);

Serial.print("H1= ");Serial.print(H1);
Serial.print(" H2= ");Serial.print(H2);
Serial.print(" H3= "); Serial.println(H3);

//WIFI UDP SETUP

  //Connect to the WiFi network
  WiFi.begin(ssid, pwd);
  Serial.println("");

  Serial.print("ESP Board MAC Address:  ");
  Serial.println(WiFi.macAddress());
  // Wait for connection
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("");
  Serial.print("Connected to ");
  Serial.println(ssid);
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());
  //This initializes udp and transfer buffer
  Udp.begin(localPort);
  strcpy(udpAddress,udpAddress0); 
  ///////


//////ARDUINO OTA 
ArduinoOTA
    .onStart([]() {
      String type;
      if (ArduinoOTA.getCommand() == U_FLASH)
        type = "sketch";
      else // U_SPIFFS
        type = "filesystem";

      // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
      Serial.println("Start updating " + type);
    })
    .onEnd([]() {
      Serial.println("\nEnd");
    })
    .onProgress([](unsigned int progress, unsigned int total) {
      Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
    })
    .onError([](ota_error_t error) {
      Serial.printf("Error[%u]: ", error);
      if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
      else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
      else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
      else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
      else if (error == OTA_END_ERROR) Serial.println("End Failed");
    });

  ArduinoOTA.begin();
  /////////////////////////////////////
//  
////  //particule address selection  
  std::string EndMAC{WiFi.macAddress()[12],WiFi.macAddress()[13],WiFi.macAddress()[14],WiFi.macAddress()[15],WiFi.macAddress()[16]};
  int index=0;
  for (int i=0; i<(sizeof(ADDRESS_DATA_BASE) / sizeof(ADDRESS_DATA_BASE[0])); i++) {
     if (EndMAC == ADDRESS_DATA_BASE[i]) {
       index = i;
       // Serial.print(local[5],HEX);
        Serial.print((sizeof(ADDRESS_DATA_BASE) / sizeof(ADDRESS_DATA_BASE[0])));Serial.print(" adresses to choose from, index: ");Serial.println(index);    
       break;
     }
     else{Serial.println("No adress found ");index=-1;}
  }
  IPAddress local=WiFi.localIP();

//Serial.print("Two last char of MAC address: ");Serial.println(EndMAC);

// 
 //intitialisation of Motor structure
  //Motor.Address=ADDRESS_DATA_BASE[index][1];//ADDRESS
  Motor.Address=index+1;//ADDRESS
  Motor.Mode=0;
  Motor.Speed=0;
  Motor.Speed_target=5;
  Motor.Torque=0;
  Motor.Max_Torque=255;
  Motor.Angle=0;
  Motor.Angle_target=0;
  Motor.Direction=true;
  Motor.State=0;
  Motor.PWM=0;
  Motor.Vshift=0;
  Motor.Minus_State=false;
  Motor.Plus_State=false;
 Serial.print("Motor address:");Serial.println(Motor.Address);
  
/////deep sleep mode setup
++bootCount;
  Serial.println("Boot number: " + String(bootCount));

  //Print the wakeup reason for ESP32
  print_wakeup_reason();

  /*
  First we configure the wake up source
  We set our ESP32 to wake up for an external trigger.
  There are two types for ESP32, ext0 and ext1 .
  ext0 uses RTC_IO to wakeup thus requires RTC peripherals
  to be on while ext1 uses RTC Controller so doesnt need
  peripherals to be powered on.
  Note that using internal pullups/pulldowns also requires
  RTC peripherals to be turned on.
  */
  esp_sleep_enable_ext0_wakeup(GPIO_NUM_5,1); //1 = High, 0 = Low

  /////////

  tp.DotStar_SetPower(true);
  tp.DotStar_SetPixelColor(0,200,0);
  tp.DotStar_Show();
  delay(2000);
  ///turn off RGB LED power to save battery life
  tp.DotStar_SetPower(false);
  
  
  ////SETUP SENSORS
  //Tlv493d
  Tlv493dMagnetic3DSensor.begin();
  Serial.println("Tlv493d Found!");
  Tlv493dMagnetic3DSensor.setAccessMode(Tlv493dMagnetic3DSensor.MASTERCONTROLLEDMODE);
  Tlv493dMagnetic3DSensor.disableTemp();

    //LSM6DSOX

    lsm6dsox.setAccelRange(LSM6DS_ACCEL_RANGE_4_G);
    lsm6dsox.setGyroRange(LSM6DS_GYRO_RANGE_2000_DPS); 
    lsm6dsox.setAccelDataRate(LSM6DS_RATE_208_HZ);
    lsm6dsox.setGyroDataRate(LSM6DS_RATE_208_HZ);

  while (!Serial)
    delay(10); // will pause Zero, Leonardo, etc until serial console opens 

  Serial.println("Adafruit lsm6dsox test!");

  if(!lsm6dsox.begin_I2C(0x6A)){
    Serial.println("Failed first attempt");
    if(!lsm6dsox.begin_I2C(0x6B)){
      Serial.println("Failed to find lsm6dsox chip");
      while (1) delay(10);
    }
  }

  Serial.println("lsm6dsox Found!");

  delay(500);

  // if (! ina219.begin()) {
  //   Serial.println("Failed to find INA219 chip");
  //   while (1) { delay(10); }
  // }
  // Serial.println("INA219 Found!");

    //Encoder
  pinMode(MA.PIN, INPUT);
  attachInterrupt(MA.PIN, isr_A, CHANGE);
  pinMode(MB.PIN, INPUT);
  attachInterrupt(MB.PIN, isr_B, CHANGE);
  Serial.print("ticks per tour=");Serial.println(tour);
  ////////


  //ENABLE BOOST
  pinMode(EN_BOOST, OUTPUT);
  digitalWrite(EN_BOOST, HIGH);// Start with Boost on.  

  //MOTOR SETUP
    //Initialize the motor driver switch pin.
  pinMode(MOT_SLP_PIN, OUTPUT);
  digitalWrite(MOT_SLP_PIN, HIGH);// Start with drivers on.
    //PWM setup 
  ledcSetup(MotChannel1, freq, resolution);
  ledcSetup(MotChannel2, freq, resolution);

  ledcAttachPin(MOT_A1_PIN, MotChannel1);
  ledcAttachPin(MOT_A2_PIN, MotChannel2);
  ///////
  
  //PID
  pidcontroller.begin(); // initialize the PID instance
  pidcontroller.tune(__Kp,__Ki,__Kd); // Tune the PID, arguments: kP, kI, kD
  pidcontroller.limit((-1)*Motor.Max_Torque, Motor.Max_Torque); // Limit the PID output between -255 to 255, this is important to get rid of integral windup!


  //PID speed
  pidcontroller_speed.begin(); // initialize the PID instance
  pidcontroller_speed.tune(__Kps,__Kis,__Kds); // Tune the PID, arguments: kP, kI, kD
  pidcontroller_speed.limit((-1)*Motor.Max_Torque, Motor.Max_Torque); // Limit the PID output between -255 to 255, this is important to get rid of integral windup!

   Serial.print("PWM freq= ");Serial.println(FREQ);

//// Get a *rough* estimate of the current battery voltage
  // If the battery is not present, the charge IC will still report it's trying to charge at X voltage
  // so it will still show a voltage.
  Serial.print("Battery level: ");
  Serial.println(tp.GetBatteryVoltage());
  Serial.print("Battery charging in progress: ");
  Serial.println(tp.IsChargingBattery());  
  delay(2000);
  Serial.print("battery level= ");Serial.print(((tp.GetBatteryVoltage()-3.5)/0.70)*100);Serial.println("%");

  //initialize counter for Calibration procedure
  int incr_cal=(-1)*Cal_interval;


// //initialize Angle_field
// for (int thisReading = 0; thisReading < buffersize_angle_field; thisReading++) {
//     Angle_field[thisReading] = 0;
//   }

}//end setup loop

void loop(){

  //Serial.print(micros());

  //Handle to execut for new firmware upload 
  ArduinoOTA.handle();
  
  // //get magnetometer data
  // delay(Tlv493dMagnetic3DSensor.getMeasurementDelay());
  // Tlv493dMagnetic3DSensor.updateData();
  // //Cartesian
    // Serial.print(Tlv493dMagnetic3DSensor.getX());
    // Serial.print(" ; ");
    // Serial.print(Tlv493dMagnetic3DSensor.getY());
    // Serial.print(" ; ");
    // Serial.println(Tlv493dMagnetic3DSensor.getZ());
    // //Spherical
    // Serial.print(Tlv493dMagnetic3DSensor.getAmount());
    // Serial.print(" ; ");
    // Serial.print(Tlv493dMagnetic3DSensor.getAzimuth());
    // Serial.print(" ; ");
    // Serial.println(Tlv493dMagnetic3DSensor.getPolar());


  /* Get a new normalized sensor event */
  sensors_event_t accel;
  sensors_event_t gyro;
  sensors_event_t temp;
  //Serial.print(" "); Serial.println(micros());

  lsm6dsox.getEvent(&accel, &gyro, &temp);

  //Serial.println(millis());
  //Serial.println(lsm6dsox.rawAccX);

  //angle encoder increment definition theta=encoder_count in [0 tour] with tour= gear ration * 12 
  if (encoder_count>tour-1){encoder_count=encoder_count-tour;}   
  if (encoder_count<0){encoder_count=tour+encoder_count;}
  //Serial.println(encoder_count);

  ////READ SPEED FROM SERVER
  char buffer4[40];
  memset(buffer4, 0, 40);     
  Udp.parsePacket(); 
  if(Udp.read(buffer4, 40) > 0){
    //Serial.println("Message received");

    MatchState ms;
    ms.Target(buffer4);      
    //Serial.println(buffer4);
    
    char resultIP=ms.Match ("(IP)(%d+.%d+.%d+.%d+)",0);
    //Serial.println(resultIP);
    if (resultIP == REGEXP_MATCHED){
      char captureBufIP [20];
      strcpy(udpAddress, ms.GetCapture (captureBufIP,1));
      Serial.print("Telemetry com IP changed to ");Serial.println(udpAddress);
    }  

    char resultPoke=ms.Match ("(Po)",0);
    //Serial.println(resultPoke);
    if (resultPoke == REGEXP_MATCHED){
      Serial.println("Poke");
      Poke=1; 
      previousMillis1 = millis();
    }  


 ////change general form parameters// cmd all UAGU0.0A0.0G0.0Am0.0T0.1;
    char resultUAG=ms.Match ("(UAG)(U)(%d+.%d+)(A)(%+?%-?%d+.%d+)(G)(%d+.%d+)(;)",0); //(B)(%d+.%d+)
    if (resultUAG == REGEXP_MATCHED){
      char captureBufUAG [45];     
      Serial.println("UAG parameters changed"); 
      // for (int i = 0; i <sizeof(ADDRESS_DATA_BASE)/sizeof(char *); i++){
      //     if (Motor.Address==Part_Sequence_int[i]){
      //       U0=(pow(-1,i+1))*atof(ms.GetCapture (captureBufUAG,2));//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
      //       Serial.print("U0= ");Serial.print(U0); 
      //     }  
      //   }

      U=atof(ms.GetCapture (captureBufUAG,2));
      A=atof(ms.GetCapture (captureBufUAG,4));
      G=atof(ms.GetCapture (captureBufUAG,6));
      //alpha_EMA=atof(ms.GetCapture (captureBufUAG,8));

      // Amp=atof(ms.GetCapture (captureBufUAG,8));
      // period_wave=atof(ms.GetCapture (captureBufUAG,10));
      // pulsation=2*M_PI/period_wave;

      Serial.print("Uspin= ");Serial.print(U0);
      Serial.print(" U= ");Serial.print(U);
      Serial.print(" A= ");Serial.print(A);
      Serial.print(" G= "); Serial.print(G);
      Serial.print(" alpha_EMA= "); Serial.print(alpha_EMA);
      Serial.print(" Amp= "); Serial.print(Amp);
      Serial.print(" period_wave= "); Serial.println(period_wave);

    }

    char resultOscV=ms.Match ("(SinV)(Am)(%+?%-?%d+.%d+)(T)(%d+.%d+)(;)",0);
    if (resultOscV == REGEXP_MATCHED){
      char captureBufOscV [45];     
      Serial.println("Osc V parameters changed"); 

      Amp=atof(ms.GetCapture (captureBufOscV,2));
      period_wave=atof(ms.GetCapture (captureBufOscV,4));
      pulsation=2*M_PI/period_wave;

      Serial.print("Uspin= ");Serial.print(U0);
      Serial.print(" U= ");Serial.print(U);
      Serial.print(" A= ");Serial.print(A);
      Serial.print(" G= "); Serial.print(G);
      Serial.print(" alpha_EMA= "); Serial.print(alpha_EMA);
      Serial.print(" Amp= "); Serial.print(Amp);
      Serial.print(" period_wave= "); Serial.println(period_wave);

    }



    char resultVspin=ms.Match ("(Vspin)(%d+.%d+)(;)",0);
    if (resultVspin == REGEXP_MATCHED){
      char captureBufVspin [10];     
      Serial.println("V spin parameters changed"); 
      for (int i = 0; i <sizeof(ADDRESS_DATA_BASE)/sizeof(char *); i++){
          if (Motor.Address==Part_Sequence_int[i]){
            U0=(pow(-1,i+1))*atof(ms.GetCapture (captureBufVspin,1));//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
            Serial.print("U0= ");Serial.print(U0); 
          }  
        }

      Serial.print("Uspin= ");Serial.print(U0);
      Serial.print(" U= ");Serial.print(U);
      Serial.print(" A= ");Serial.print(A);
      Serial.print(" G= "); Serial.print(G);
      Serial.print(" alpha_EMA= "); Serial.print(alpha_EMA);
      Serial.print(" Amp= "); Serial.print(Amp);
      Serial.print(" period_wave= "); Serial.println(period_wave);

    }

    char resultVbias=ms.Match ("(Vbias)(%+?%-?%d+.%d+)(;)",0);
    if (resultVbias == REGEXP_MATCHED){
      char captureBufVbias [10];     
      Serial.println("V bias parameters changed"); 
      Ub=atof(ms.GetCapture (captureBufVbias,1));//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
      Serial.print("Ub= ");Serial.print(Ub); 
      Serial.print(" Uspin= ");Serial.print(U0);
      Serial.print(" U= ");Serial.print(U);
      Serial.print(" A= ");Serial.print(A);
      Serial.print(" G= "); Serial.print(G);
      Serial.print(" alpha_EMA= "); Serial.print(alpha_EMA);
      Serial.print(" Amp= "); Serial.print(Amp);
      Serial.print(" period_wave= "); Serial.println(period_wave);

    }


////Execute general form state
    char resultRand=ms.Match ("(Rand)(%d)(t)(%d+)(;)",0);//time in ms
    if (resultRand == REGEXP_MATCHED){
      char captureBufRand [10];     
      timeRand=atoi(ms.GetCapture (captureBufRand,3));
      if (atoi(ms.GetCapture (captureBufRand,1))==1){
        randomize=true; 
        Serial.println("Randomize ON, mode GF");
      } else{
          Serial.println("Randomize OFF, mode GF");
          randomize=false; 
        } 
    }

////Execute general form state
    char resultGF=ms.Match ("(GF)",0);
    if (resultGF == REGEXP_MATCHED){
      Serial.println("Motor state ON, mode GF");
      Motor.State=19; 
      theta_star=0; 
      previous_encoder_count=encoder_count; 
      //encoder_count_prev=encoder_count;         
    } 

  /////////////// Wave chenille motion for obstacle (decentralized control in PWM) (in progress)
    char resultWaveC=ms.Match ("(WaveC)(U)(%+?%-?%d+)(A)(%d+)(T)(%+?%-?%d+.%d+)(;)",0);
    if (resultWaveC == REGEXP_MATCHED){
        char captureBufWaveC [30];           
        for (int i = 0; i <sizeof(ADDRESS_DATA_BASE)/sizeof(char *); i++){
          if (Motor.Address==Part_Sequence_int[i]){
            U0=(pow(-1,i+1))*atoi(ms.GetCapture (captureBufWaveC,2));//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
            phi=(i-1)*(4*M_PI/(sizeof(ADDRESS_DATA_BASE)/sizeof(char *)));
          }  
        }
        Amp=atoi(ms.GetCapture (captureBufWaveC,4));
        period_wave=atof(ms.GetCapture (captureBufWaveC,6));

        time_wave_0 = millis();

        Motor.State=18;
        Serial.print("Wave obstacle mode, U0="); 
        Serial.print(U0);
        Serial.print(" A="); 
        Serial.print(A);
        Serial.print(" T="); 
        Serial.print(period_wave);
        Serial.print(" s");
        Serial.print(" phi="); 
        Serial.println(phi);

    }


    char resultCal=ms.Match ("(Cal;)",0);
    if (resultCal == REGEXP_MATCHED){
      Serial.println("Enter Calibration Procedure - Fast decay");
      Motor.State=3; 
      encoder_count_prev=encoder_count; 
      incr_cal=(-1)*Cal_interval;         
    } 

    char resultCalS=ms.Match ("(CalS;)",0);
    if (resultCalS == REGEXP_MATCHED){
      Serial.println("Enter Calibration Procedure - Slow decay");
      Motor.State=10; 
      encoder_count_prev=encoder_count; 
      incr_cal=(-1)*Cal_interval;         
    } 


    char resultCalS2=ms.Match ("(CalS2;)",0);
    if (resultCalS2 == REGEXP_MATCHED){
      Serial.println("Enter Calibration Procedure - Slow decay 128");
      Motor.State=11; 
      encoder_count_prev=encoder_count; 
      incr_cal=(-1)*Cal_interval;        
    } 

    char resultPWMF=ms.Match ("(PWMF)(%d+)(;)",0);//update 5/21/2022
    if (resultPWMF == REGEXP_MATCHED){
      char bufferPWMF[10];
      freq=atoi(ms.GetCapture(bufferPWMF,1));
      ledcSetup(MotChannel1, freq, resolution);
      ledcSetup(MotChannel2, freq, resolution);
      ledcAttachPin(MOT_A1_PIN, MotChannel1);
      ledcAttachPin(MOT_A2_PIN, MotChannel2);
      Serial.print("PWM frequency changed to ");Serial.println(freq);       
    } 
    
    
    char resultC_time=ms.Match ("(C_time)(%d+)(;)",0);//update 5/21/2022
    if (resultC_time == REGEXP_MATCHED){
      char bufferC_time[10];
      Cal_time=atoi(ms.GetCapture(bufferC_time,1));
      Serial.print("Calibration time changed to ");Serial.println(Cal_time);       
    } 

    char resultdt_DR=ms.Match ("(dt_DR)(%d+E%-?%d+)(;)",0);//update 5/21/2022
    if (resultdt_DR == REGEXP_MATCHED){
      char bufferdt_DR[20];
      dt_DR=atof(ms.GetCapture(bufferdt_DR,1));
      Serial.print("speed sampling time changed to ");Serial.println(dt_DR);       
    } 


// Init all procdure with handcheck or alternating speed sign (requier to now direct neighbor) 
    char resultHandi=ms.Match ("(HandInit)(%s)(.+)(;)",0);
    //char resultHandi=ms.Match ("(HandInit)(%s)(.+)(n)(%d+)(;)",0);
    if (resultHandi == REGEXP_MATCHED){
      time_count=0;
      tp.DotStar_SetPower(false);
      encoder_count_prev=encoder_count;

      Serial.println("Handcheck Soliton init");
      char Part_Sequence_raw [45];
      
      memset(Part_Sequence_raw,0,40);
      ms.GetCapture(Part_Sequence_raw,2);
      int sizeSeqRaw=0;

       for (int i = 0; i < sizeof(Part_Sequence_raw)/sizeof(Part_Sequence_raw[0]); i++){
        if (Part_Sequence_raw[i] != 0){sizeSeqRaw++;} 
       }

      //Serial.print("Bots sequence: ");Serial.println(Part_Sequence_raw);
      int SpCount=0;
      int SpArr[sizeSeqRaw];
      String Part_Sequence[sizeSeqRaw];
      
    //command sent from terminal: cmd all HandInit /1/10/3/8/9/2/5/4/;
      //Serial.print("separators at ");
      SpArr[0]=0;     
      for (int i = 0; i <sizeSeqRaw; i++){
        if(Part_Sequence_raw[i]=='/'){ //char(32) corresponds to a space ' '
          SpArr[SpCount]=i;
          //Serial.print(SpArr[SpCount]);Serial.print(' ');
          SpCount++;
        }
      }
      //Serial.println();
  
      //Serial.println("Parsed sequence: ");
      for (int i = 0; i <SpCount-1; i++){
        for (int j = SpArr[i]+1; j <SpArr[i+1]; j++){
          Part_Sequence[i]=Part_Sequence[i]+Part_Sequence_raw[j];
        }
        //n = Part_Sequence[i].length();
        //char Neighbor_address[n + 1];
        Part_Sequence_int[i]=atoi(Part_Sequence[i].c_str());
        //Serial.println(Part_Sequence[i]);
        //Serial.println(Part_Sequence_int[i]);
      }
      
      int Seq_pos=0;
      for (int i = 1; i <SpCount; i++){
          if(String(Motor.Address)==Part_Sequence[i-1]){
            Seq_pos=i;     
            //Serial.print("pos in seq: ");Serial.println(Seq_pos);      
          }
      }
      Serial.print("pos in seq: ");Serial.println(Seq_pos);
      Serial.print("size: ");Serial.println(SpCount-1);

      if (Seq_pos!=SpCount-1){
        // n = Part_Sequence[Seq_pos+1].length();
        // char Neighbor_address[n + 1];
        // strcpy(Neighbor_address, Part_Sequence[Seq_pos+1].c_str());
        // Neighbor_address_int=atoi(Neighbor_address);
        Neighbor_address_int=Part_Sequence_int[Seq_pos];
      } else {
          Neighbor_address_int=Part_Sequence_int[0];
          // n = Part_Sequence[0].length();
          // char Neighbor_address[n + 1];
          // strcpy(Neighbor_address, Part_Sequence[0].c_str());
          // Neighbor_address_int=atoi(Neighbor_address);     
      }
      if (Seq_pos==0){Neighbor_address_int=0;}

      Serial.print("neighbor address: ");Serial.println(Neighbor_address_int);


      //Motor.State=4; 
      encoder_count_prev=encoder_count;
      // //ParseStr(Part_Sequence_raw, Part_Sequence_vec[30]);
      String buf =  String("d"+String(Motor.Address)+"-" + WiFi.localIP()[0]+'.'+ WiFi.localIP()[1]+'.'+ WiFi.localIP()[2]+'.'+ WiFi.localIP()[3]+';');   
      Serial.print("IP message sent: ");Serial.println(buf);

      //sol_n = atoi(ms.GetCapture (Part_Sequence_raw,4));

      Udp.beginPacket(udpAddress0, localPort);   
      //itoa(Motor.Angle, buffer1,10);
      //Udp.print("A");
      Udp.print(buf);
      Udp.endPacket();

    } 


    char resultIPpart=ms.Match ("(d)(%d+)(-)(%d+.%d+.%d+.%d+)(;)",0);
    if (resultIPpart == REGEXP_MATCHED){
      char captureBufIPpart [20];   
      Serial.print("IP received from particule "); Serial.println(ms.GetCapture (captureBufIPpart,1));
      Serial.println(ms.GetCapture (captureBufIPpart,3));
      if (atoi(ms.GetCapture (captureBufIPpart,1))==Neighbor_address_int){
        strcpy(udpAddressN,ms.GetCapture (captureBufIPpart,3));
        Serial.print("Neighbor's IP: ");Serial.println(udpAddressN);  
      }     
      // IPparts[atoi(ms.GetCapture (captureBufIPpart,0))]=ms.GetCapture (captureBufIPpart,2);
      // strcpy(udpAddressN,IPparts[Neighbor_address_int]);
      // Serial.print("Neighbor's IP: ");Serial.println(udpAddressN);  
    } 


//change kinematic coef for Handcheck based displacement control soliton 
    char resultHandCoef=ms.Match ("(HandC)(%+?%-?%d+)(,)(%+?%-?%d+)(,)(%+?%-?%d+)(,)(%+?%-?%d+)(,)(%+?%-?%d+)(;)",0);
    if (resultHandCoef == REGEXP_MATCHED){
      char captureBufHandCoef [35];     
      Serial.println("Handcheck Soliton Coef changed");  
  
      sol_coef0=atoi(ms.GetCapture (captureBufHandCoef,1));
      sol_coef[0]=atoi(ms.GetCapture (captureBufHandCoef,3));
      sol_coef[1]=atoi(ms.GetCapture (captureBufHandCoef,5));
      sol_coef[2]=atoi(ms.GetCapture (captureBufHandCoef,7));
      sol_coef[3]=atoi(ms.GetCapture (captureBufHandCoef,9));
    } 


////change PID parameters for speed
    char resultPIDS=ms.Match ("(PIDS)(P)(%d+)(I)(%d+)(D)(%d+)(;)",0);
    if (resultPIDS == REGEXP_MATCHED){
      char captureBufPIDS [30];     
      Serial.println("Speed PID parameters changed");  
      pidcontroller_speed.tune(atoi(ms.GetCapture (captureBufPIDS,2)),atoi(ms.GetCapture (captureBufPIDS,4)),atoi(ms.GetCapture (captureBufPIDS,6))); // Tune the PID, arguments: kP, kI, kD
      Serial.print("P= ");Serial.print(atoi(ms.GetCapture (captureBufPIDS,2)));
      Serial.print(" I= ");Serial.print(atoi(ms.GetCapture (captureBufPIDS,4)));
      Serial.print(" D= "); Serial.println(atoi(ms.GetCapture (captureBufPIDS,6)));
    }

    ////change PID parameters for speed
    char resultPID=ms.Match ("(PID)(P)(%d+)(I)(%d+)(D)(%d+)(;)",0);
    if (resultPID == REGEXP_MATCHED){
      char captureBufPID [30];     
      Serial.println("Speed PID parameters changed");  
      pidcontroller.tune(atoi(ms.GetCapture (captureBufPID,2)),atoi(ms.GetCapture (captureBufPID,4)),atoi(ms.GetCapture (captureBufPID,6))); // Tune the PID, arguments: kP, kI, kD
      Serial.print("P= ");Serial.print(atoi(ms.GetCapture (captureBufPID,2)));
      Serial.print(" I= ");Serial.print(atoi(ms.GetCapture (captureBufPID,4)));
      Serial.print(" D= "); Serial.println(atoi(ms.GetCapture (captureBufPID,6)));
    }

/////kinematic soliton (displacement controlled perturbation propagation)
    char resultHand=ms.Match ("(Hand)(T)(%d+)(A)(%d+)(SG)(%d+)(;)",0);
    if (resultHand == REGEXP_MATCHED){
      
      
      tp.DotStar_SetPower(false);  
      char captureBufHand [35];     
      Serial.print("Handcheck Soliton ON, first bots ");  
      time_count=0;

      //Motor.State=4;// for angle constrain


      Serial.println(Part_Sequence_int[0]);  
      encoder_count_prev=encoder_count;
      //sol_pulse = atoi(ms.GetCapture (captureBufHand,2));
      sol_period = atoi(ms.GetCapture (captureBufHand,2));
      sol_amp = atoi(ms.GetCapture (captureBufHand,4));
      //sol_speed_p = atoi(ms.GetCapture (captureBufHand,6));
      sol_speed_g = atoi(ms.GetCapture (captureBufHand,6));
     

      //theta_eq=encoder_count; 
      theta_star=0;
      refresh=round(sol_period/Sample_Hand);  
      //Serial.print("refresh period: "); Serial.println(refresh);

      //Serial.print("pulsation = ");Serial.print(sol_pulse);
      Serial.print("Amplitude = ");Serial.print(sol_amp);Serial.print(", Speed = ");Serial.println(sol_speed_g);   
      if(Motor.Address==Part_Sequence_int[0]){
        Udp.beginPacket(udpAddressN, localPort);   
        char bufcheck[3]={'O',';'};  
        Udp.print(bufcheck);
        Udp.endPacket();
      }
       
    } 

    char resultHandStop=ms.Match ("(HandStop;)",0);
    if (resultHandStop == REGEXP_MATCHED){
      Serial.println("Soliton STOP");
      Motor.PWM=0;
      Motor.State=0;
      tp.DotStar_SetPower(false);

    }

    char resultCHECK=ms.Match ("(O;)",0);
    if (resultCHECK == REGEXP_MATCHED){
      //Serial.println("Neighbor Master CHECK");
      Motor.State=4;// remove for angle constrain
      sol_mode=1;
      Neighbor_count=0;
      //time_count=0; //for angle constrain
      
      previousMillis7 = millis();
      previousMillis8 = millis();
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(30,0,30);
      tp.DotStar_Show(); 

      Udp.beginPacket(udpAddressN, localPort); 
      char bufcheckTS[6];
      memset(bufcheckTS, 0, 6); 
      sprintf(bufcheckTS,"TS%i;",Neighbor_count);       
      //Serial.println(bufcheckTS);
      Udp.print(bufcheckTS);
      Udp.endPacket();

    }  


    char resultTrigSlave=ms.Match ("(TS)(%d+)(;)",0);
    //char resultC=ms.Match ("(M%s)(%d+)(%s)(/)(%s)(%d+)(%s)(/)(%s)(%d+)(%s)(;)",0);
    if (resultTrigSlave == REGEXP_MATCHED){
      
      char captureBufTrigSlave [10];  
      
      Neighbor_count=atoi(ms.GetCapture (captureBufTrigSlave,1))+1;
      Serial.print("Neighbor Slave CHECK to i+");Serial.println(Neighbor_count);

      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(0,0,30);
      tp.DotStar_Show(); 

      if (Neighbor_count<sol_n){
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckTS[6];
        memset(bufcheckTS, 0, 6); 
        sprintf(bufcheckTS,"TS%i;",Neighbor_count);       
        //Serial.println(bufcheckTS);
        Udp.print(bufcheckTS);
        Udp.endPacket();
      }
    }  

    char resultC=ms.Match ("(M)(%+?%-?%d+)(;)",0);
    //char resultC=ms.Match ("(M)(%d+)(/)(%d+)(/)(%d+)(;)",0);
    //char resultC=ms.Match ("(M%s)(%d+)(%s)(/)(%s)(%d+)(%s)(/)(%s)(%d+)(%s)(;)",0);
    if (resultC == REGEXP_MATCHED){
      //Serial.println("Neighbor Slave CHECK");
      char captureBufS [15];  
      Motor.State=4;// remove for angle constrain
      sol_mode=2;
      //time_count=0; //for angle constrain
      //Master_Address=atoi(ms.GetCapture (captureBufS,1));
      Master_dtheta=atoi(ms.GetCapture (captureBufS,1));
      //Neighbor_count=atoi(ms.GetCapture (captureBufS,5))+1;

      //previousMillis7 = millis();
      //previousMillis8 = millis();
      //tp.DotStar_SetPower(true);
      //tp.DotStar_SetPixelColor(0,0,30);
      //tp.DotStar_Show(); 

      if (Neighbor_count<sol_n){
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckS[15];
        memset(bufcheckS, 0, 15); 
        sprintf(bufcheckS,"M%i;", Master_dtheta);       
        //Serial.println(bufcheckS);
        Udp.print(bufcheckS);
        Udp.endPacket();
      }

    }  

    /////roll mode with leader and follower.
    //char resultHandRoll=ms.Match ("(HandRoll)(%d)(/)(%+?%-?%d+)/(%d)(;)",0);
    char resultHandRoll=ms.Match ("(HandRoll)(%d+)(/)(%+?%-?%d+)(;)",0);
    if (resultHandRoll == REGEXP_MATCHED){
      char captureBufRoll [25];     
      //pidcontroller.setpoint(0);
      Serial.print("Hand Roll mode, Speed=");  
      theta_star=0;
      previous_tstar=0;
      Motor.State=5;
      AddressLead=atoi(ms.GetCapture (captureBufRoll,1));
      speed_roll=atoi(ms.GetCapture (captureBufRoll,3));
      //Move_amp=atoi(ms.GetCapture (captureBufRoll,5));
      Serial.println(speed_roll);
      if (Motor.Address==AddressLead){ 
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(30,0,30);
      tp.DotStar_Show(); 
      }

    } 

    //char resultSlaveR=ms.Match ("(MR)(%d+)(/)(%+?%-?%d)(;)",0);
    char resultSlaveR=ms.Match ("(MR)(%+?%-?%d+)(;)",0);
    if (resultSlaveR == REGEXP_MATCHED){
      //Serial.println("Neighbor Slave CHECK");
      char captureBufSlaveR [15];  
      Master_dtheta=(-1)*atoi(ms.GetCapture (captureBufSlaveR,1));
      //coef_roll=atoi(ms.GetCapture (captureBufSlaveR,3));
      previousMillis7 = millis();
      
      if (Neighbor_address_int!=AddressLead){
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckS[15];
        memset(bufcheckS, 0, 15); 
        sprintf(bufcheckS,"MR%i;", Master_dtheta);       
        //Serial.println(bufcheckS);
        Udp.print(bufcheckS);
        Udp.endPacket();
      }

      Motor.State=5;// remove for angle constrain

    }  
    //////////////////////////////////////

    char resultHybComp=ms.Match ("(HybComp)(%+?%-?%d+)(,)(%+?%-?%d+)(,)(%d+)(;)",0);// Simple PWM control
    if (resultHybComp == REGEXP_MATCHED){
      char captureHybComp [35];     
      //pidcontroller.setpoint(0);
      //Serial.println("Direct Roll mode, sequence=");  
      
      theta_star=0;
      previous_tstar=0;
      dt_DR=5E-3;
      range_dtheta=atof(ms.GetCapture (captureHybComp,3));
      range_Init=true;

      Serial.print("Range Roll mode, speed=");  
      for (int i = 0; i <sizeof(ADDRESS_DATA_BASE)/sizeof(char *); i++){
      //Serial.println(Part_Sequence_int[i]); 
        if (Motor.Address==Part_Sequence_int[i]){
         speed_roll=(pow(-1,i+1))*atof(ms.GetCapture (captureHybComp,1))*dt_DR;//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
         range_PWM=(pow(-1,i+1))*atoi(ms.GetCapture (captureHybComp,5));
         Serial.println(speed_roll);
         //Serial.println(1000*dt_DR);
         //Serial.print("Position in sequence: "); Serial.println(i+1);
        }
      Serial.print("Range dtheta=");  Serial.println(range_dtheta);
      Serial.print("Range PWM=");  Serial.println(range_PWM);

      }
    
      Motor.State=15;
      previousMillis14 = millis(); 

    } 

    /////direct roll mode 
    //char resultHandRoll=ms.Match ("(HandRoll)(%d)(/)(%+?%-?%d+)/(%d)(;)",0);
    char resultDRoll=ms.Match ("(DR)(%+?%-?%d+)(;)",0);
    if (resultDRoll == REGEXP_MATCHED){
      char captureBufDRoll [25];     
      //pidcontroller.setpoint(0);
      //Serial.println("Direct Roll mode, sequence=");  
      Serial.print("Direct Roll mode, speed=");  
      theta_star=0;
      previous_tstar=0;
      dt_DR=5E-3;
      
      for (int i = 0; i <sizeof(ADDRESS_DATA_BASE)/sizeof(char *); i++){
      //Serial.println(Part_Sequence_int[i]); 
        if (Motor.Address==Part_Sequence_int[i]){
         speed_roll=(pow(-1,i+1))*atof(ms.GetCapture (captureBufDRoll,1))*dt_DR;//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
         Serial.println(speed_roll);
         //Serial.println(1000*dt_DR);
         //Serial.print("Position in sequence: "); Serial.println(i+1);
        }
      
      }
    
      Motor.State=6;
      previousMillis9 = millis(); 

    } 

//////////////////Direct Force (PWM) controled roll FAST CURRENT DECAY (Soften the system at the treshold)
    char resultDRollF=ms.Match ("(DRF)(%+?%-?%d+)(;)",0);
    if (resultDRollF == REGEXP_MATCHED){
      char captureBufDRollF [25];     
      Serial.print("Direct constant force Roll mode, PWM=");       
      for (int i = 0; i <sizeof(ADDRESS_DATA_BASE)/sizeof(char *); i++){
        if (Motor.Address==Part_Sequence_int[i]){
         Motor.PWM=(pow(-1,i+1))*atoi(ms.GetCapture (captureBufDRollF,1));//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
        }  
      }
      Motor.State=7;
      Serial.println(Motor.PWM);
    } 

//////////////////Direct Force (PWM) controled roll SLOW CURRENT DECAY (Soften the system at the treshold)
    char resultDRollFS=ms.Match ("(DRFS)(%+?%-?%d+)(;)",0);
    if (resultDRollFS == REGEXP_MATCHED){
      char captureBufDRollFS [25];     
      Serial.print("Direct constant force Roll mode, PWM=");       
      for (int i = 0; i <sizeof(ADDRESS_DATA_BASE)/sizeof(char *); i++){
        if (Motor.Address==Part_Sequence_int[i]){
         Motor.PWM=(pow(-1,i+1))*atoi(ms.GetCapture (captureBufDRollFS,1));//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
        }  
      }
      Motor.State=12;
      Serial.println(Motor.PWM);
    } 

  //////////////////Force (PWM) controled soliton
    char resultHandF=ms.Match ("(HandF)(%d+)(/P)(%+?%-?%d+)(Y)(%d+)(SG)(%d+)(;)",0);
    if (resultHandF == REGEXP_MATCHED){
        
        tp.DotStar_SetPower(false);  
        char captureBufHandF [35];     
        Serial.print("Handcheck Force Soliton ON, first bot: next one after ");   
        
        AddressLead=atoi(ms.GetCapture (captureBufHandF,1));

        Serial.println(AddressLead);  
        sol_PWM = atoi(ms.GetCapture (captureBufHandF,3));
        yield_PWM= atoi(ms.GetCapture (captureBufHandF,5));
        sol_speed_g = atoi(ms.GetCapture (captureBufHandF,7));

        sol_coefF[0]=(-1)*sol_PWM;
        sol_coefF[1]=0;
        sol_coefF[2]=(-1)*yield_PWM;
        sol_coefF[3]=yield_PWM;
        sol_coefF[4]=(-1)*yield_PWM;
      
        Serial.print("Particule Start = ");Serial.print(AddressLead);
        Serial.print(", Active force = ");Serial.print(sol_PWM);
        Serial.print(", Yield = ");Serial.print(yield_PWM);
        Serial.print(", Handcheck time = ");Serial.println(sol_speed_g);   
        
        if(Motor.Address==AddressLead){
          Udp.beginPacket(udpAddressN, localPort);   
          char bufcheckF[5]={'O','F',';'};  
          Udp.print(bufcheckF);
          Udp.endPacket();
        }
        
      } 


    char resultCHECKF=ms.Match ("(OF;)",0);
    if (resultCHECKF == REGEXP_MATCHED){
        Serial.println("Neighbor Master CHECK received");
        Motor.State=8;
        
        Neighbor_count=0;
      
        Motor.PWM=sol_PWM;
        
    
        tp.DotStar_SetPower(true);
        tp.DotStar_SetPixelColor(30,0,30);
        tp.DotStar_Show(); 

        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckTSF[7];
        memset(bufcheckTSF, 0, 7); 
        sprintf(bufcheckTSF,"TSF%i;",Neighbor_count);       
        //Serial.println(bufcheckTS);
        Udp.print(bufcheckTSF);
        Udp.endPacket();

        previousMillis10 = millis();

      }  


    char resultTrigF=ms.Match ("(TSF)(%d+)(;)",0);
    //char resultC=ms.Match ("(M%s)(%d+)(%s)(/)(%s)(%d+)(%s)(/)(%s)(%d+)(%s)(;)",0);
    if (resultTrigF == REGEXP_MATCHED){
        
        char captureBufTrigF [11];  
        
        Neighbor_count=atoi(ms.GetCapture (captureBufTrigF,1))+1;
        Serial.print("Neighbor Slave CHECK to i+");Serial.println(Neighbor_count);
        //Serial.println("Neighbor slave CHECK received");

        Motor.PWM=sol_coefF[Neighbor_count-1];
        
        //Serial.print("PWM=");Serial.println(Motor.PWM);
        
        tp.DotStar_SetPower(true);
        tp.DotStar_SetPixelColor(0,0,30);
        tp.DotStar_Show(); 

        if (Neighbor_count<sol_nF){
          Udp.beginPacket(udpAddressN, localPort); 
          char bufcheckTS[7];
          memset(bufcheckTS, 0, 7); 
          sprintf(bufcheckTS,"TSF%i;",Neighbor_count);       
          //Serial.println(bufcheckTS);
          Serial.println("Neighbor slave CHECK sent");

          Udp.print(bufcheckTS);
          Udp.endPacket();
        }

        Motor.State=7;
      }  


///adjust to not come back to old last position of stiff mode
    char resultStiff=ms.Match ("(Stiff)",0);
    if (resultStiff == REGEXP_MATCHED){
      Serial.println("Motor state ON");
      Motor.State=1; 
      encoder_count_prev=encoder_count;          
    } 
    
    char resultSoft=ms.Match ("(Soft)",0);
    if (resultSoft == REGEXP_MATCHED){
      Serial.println("Motor state OFF");
      Motor.State=0; 
    } 

    char resultSpr=ms.Match ("(Spr)(%s)(%a)(%d+)(b)(%d+)(;)",0);// choose bias in the range 0-500|||choose k in the range 0-1000
    if (resultSpr == REGEXP_MATCHED){ 
      char captureBufSpr [15];     
      Motor.State=2;
      theta_eq=encoder_count; 
      theta_star=0;  
      test=0;
      bias=atoi(ms.GetCapture (captureBufSpr,5));
      Serial.println("Spring mode");
      Serial.print("Theta_eq=");Serial.println(theta_eq);
      Serial.print("bias= ");Serial.println(bias);
      Serial.print("max PWM=");Serial.println(Motor.Max_Torque);
      //Serial.print("buffer 2 =");Serial.println(ms.GetCapture (captureBufSpr,2));

      if (!strcmp(ms.GetCapture (captureBufSpr,2),"k")){
        k=atoi(ms.GetCapture (captureBufSpr,3)); 
        //theta_0=(Motor.Max_Torque-bias)*1000/k;
        theta_0=(Motor.Max_Torque)*1000/k;
        Serial.print("control k=");Serial.println(k);
        Serial.print("Theta_0=");Serial.println(theta_0);

      }
        
      if (!strcmp(ms.GetCapture (captureBufSpr,2),"t")){
        theta_0=atoi(ms.GetCapture (captureBufSpr,3)); 
        //k=(Motor.Max_Torque-bias)*1000/(theta_0);
        k=(Motor.Max_Torque)*1000/(theta_0);
        Serial.print("control Theta_0=");Serial.println(theta_0);
        Serial.print("k=");Serial.println(k);   
      }
        //k=atoi(ms.GetCapture (captureBufSpr,1)); 
        //theta_0=atoi(ms.GetCapture (captureBufSpr,3));    
    } 
    
    char resultSleep=ms.Match ("(Sl)",0);
    if (resultSleep == REGEXP_MATCHED){
        Serial.println("Going to sleep now");
        ledcWrite(MotChannel2,0);
        ledcWrite(MotChannel1,0);
        ///turn off RGB LED power to save battery life
        tp.DotStar_SetPower(true);
        tp.DotStar_SetPixelColor(30,0,0);
        tp.DotStar_Show();
        delay(2000);
        tp.DotStar_SetPower(false);
        esp_deep_sleep_start();
        delay(1000);  
      }  

    char resultSp=ms.Match ("(Sp)(%d+)(;)",0);
    if (resultSp == REGEXP_MATCHED){
        char captureBufSp [8];
        //Motor.Speed=atoi(ms.GetCapture (captureBufSp,1)); 
        Motor.Max_Torque=atoi(ms.GetCapture (captureBufSp,1));
        Serial.print("pid controller PWM limit= ");Serial.println(atoi(ms.GetCapture (captureBufSp,1)));
        pidcontroller.limit(Motor.Max_Torque*(-1), Motor.Max_Torque); // Limit the PID output between -Motor.Speed to Motor.Speed, this is important to get rid of integral windup!
        pidcontroller_speed.limit(Motor.Max_Torque*(-1), Motor.Max_Torque);
      }
       
    char resultA=ms.Match ("(A)(%d+)(;)",0);
    if (resultA == REGEXP_MATCHED){
      char captureBufA [8];
      //encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count;
      //if (encoder_Shift<(-1)*tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count+tour;}    
      //if (encoder_Shift>tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count-tour;}    
      Motor.Angle_target=atoi(ms.GetCapture (captureBufA,1));  
      //Serial.print("Motor.Angle_target=");Serial.println(Motor.Angle_target);  
      Serial.print("Angle target= ");Serial.print(Motor.Angle_target);
      Serial.print(" encoder= ");Serial.println(encoder_count); //Serial.print(" shift = ");Serial.println(encoder_Shift);
      //encoder_count_prev=atoi(ms.GetCapture (captureBufA,1));   
      encoder_count_prev=encoder_count;  
      //Motor.Ashift=encoder_Shift;  
      Motor.State=1; 
    }

    char resultM=ms.Match ("(MA)(%+?%-?%d+)(;)",0);
    if (resultM == REGEXP_MATCHED){
      char captureBufM [8];
      //ms.GetCapture (captureBufM,1);
      //encoder_Shift=encoder_count_prev+atoi(ms.GetCapture(captureBufM,1));
      //encoder_Shift=atoi(ms.GetCapture(captureBufM,1));
      //Serial.println(captureBufM);
      // if (captureBufM[0]=='+'){Motor.Minus_State=false;Motor.Plus_State=true;Serial.println("Move +");}  
      // if (captureBufM[0]=='-'){Motor.Minus_State=true;Motor.Plus_State=false;Serial.println("Move -");} 
      //Motor.Angle_target=(encoder_count_prev+atoi(ms.GetCapture(captureBufM,1)))%tour; 
      Motor.Angle_target=(encoder_count+atoi(ms.GetCapture(captureBufM,1)))%tour; 
      if (Motor.Angle_target<0){Motor.Angle_target=tour+Motor.Angle_target;}    
      Serial.print("Angle = ");Serial.print(encoder_count);Serial.print(" Angle target= ");Serial.print(Motor.Angle_target);
      Serial.print(" encoder shift= ");Serial.println(encoder_Shift);
      //encoder_count_prev=encoder_count;
      //Motor.Ashift=encoder_Shift;
      // if (atoi(ms.GetCapture(captureBufM,1))>round(tour/2)){
      //   rel_count=floor(atoi(ms.GetCapture(captureBufM,1))/(tour/2));
      // }

    }
  
    char resultMS=ms.Match ("(MS)(%+?%-?%d+)(P)(%+?%-?%d+)(;)",0);
    if (resultMS == REGEXP_MATCHED){
      char captureBufMS [8];
      Serial.print("Simple speed control mode, speed=");  
      theta_star=0;
      previous_tstar=0;
      //dt_DR=5E-3;
      speed_roll=atoi(ms.GetCapture (captureBufMS,1));//*dt_DR;//atoi(ms.GetCapture (captureBufDRoll,3))*pow(-1,i+1);
      Serial.println(speed_roll);   
      Serial.print("until shift pos= ");  
      Motor.Ashift=atoi(ms.GetCapture (captureBufMS,3));
      Serial.println(Motor.Ashift);   
      //if (Motor.Angle_target<0){Motor.Angle_target=tour+Motor.Angle_target;}    
      //Serial.print("Angle = ");Serial.print(encoder_count);Serial.print(" Angle target= ");Serial.print(Motor.Angle_target);
      //Serial.print(" encoder shift= ");Serial.println(encoder_Shift);
      //encoder_count_prev=encoder_count;
      //Motor.Ashift=encoder_Shift;
      // if (atoi(ms.GetCapture(captureBufM,1))>round(tour/2)){
      //   rel_count=floor(atoi(ms.GetCapture(captureBufM,1))/(tour/2));
      // }

      Motor.State=9;
      previousMillis11 = millis(); 

    }

    char resultF=ms.Match ("(SF)(%+?%-?%d+)(;)",0);// Simple PWM control fast decay
    if (resultF == REGEXP_MATCHED){
      char captureBufF [10];     
      Serial.print("Simple PWM control MODE F, PWM=");       
      Motor.PWM=atoi(ms.GetCapture (captureBufF,1));
      Motor.State=7;
      Serial.println(Motor.PWM);
    } 

    char resultFS=ms.Match ("(SFS)(%+?%-?%d+)(;)",0);// Simple PWM control slow decay
    if (resultFS == REGEXP_MATCHED){
      char captureBufFS [10];     
      Serial.print("Simple PWM control MODE S, PWM=");       
      Motor.PWM=atoi(ms.GetCapture (captureBufFS,1));
      Motor.State=12;
      Serial.println(Motor.PWM);
    } 

    char resultBr=ms.Match ("(Br)(%+?%-?%d+)(;)",0);// Simple PWM control
    if (resultBr == REGEXP_MATCHED){
      char captureBufBr [10];     
      Serial.print("Brake at PWM =");       
      Motor.PWM=atoi(ms.GetCapture (captureBufBr,1));
      Motor.State=13;
      Serial.println(Motor.PWM);
    } 

    char resultDiffPWM=ms.Match ("(DiffPWM)(%+?%-?%d+)(,)(%+?%-?%d+)(;)",0);// Simple PWM control
    if (resultDiffPWM == REGEXP_MATCHED){
      char captureBufBr [15];     
      Serial.print("Diff PWM =");       
      Motor.PWM=atoi(ms.GetCapture (captureBufBr,1));
      Motor.Brake_val=atoi(ms.GetCapture (captureBufBr,3));
      Motor.State=14; 
      Serial.print(Motor.PWM); Serial.print(',');Serial.println(Motor.Brake_val);
    } 

    char resultField2s=ms.Match ("(dbField)(%+?%-?%d+)(;)",0);
    if (resultField2s == REGEXP_MATCHED){
      char captureBufField2s [20];
      //encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count;
      //if (encoder_Shift<(-1)*tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count+tour;}    
      //if (encoder_Shift>tour/2){encoder_Shift=atoi(ms.GetCapture (captureBufA,1))-encoder_count-tour;}    
      t_0=millis();
      previous_t=0;
      //Angle_field_target=atoi(ms.GetCapture (captureBufField2s,1))*(tour/360); //IN RAD!!
      Angle_field_target=atof(ms.GetCapture (captureBufField2s,1))*(tour/360);; //INPUT BY USER IN DEG!! converted in steps
      //Angle_field_0=encoder_count*2*M_PI/tour;
      tilt_star=0.0;
      theta_star=0;//in steps, NOT IN RAD!!
      //readIndex=0;
      //total=0;
      //average=0;

      // if (accel.acceleration.x>=0 && accel.acceleration.y>=0){
      //   tilt_0=atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
      // }
      //   else if (accel.acceleration.x>=0 && accel.acceleration.y<=0){
      //     tilt_0=atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
      //   }
      //     else if (accel.acceleration.x<=0 && accel.acceleration.y<=0){
      //       tilt_0=-1*M_PI+atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
      //     }
      //       else if (accel.acceleration.x<=0 && accel.acceleration.y>=0){
      //         tilt_0=M_PI+atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
      //       } 
      

      if ((angle_x>=0) & (angle_y>=0)){
        tilt_0 = atan(accel.acceleration.y/sqrt(pow(accel.acceleration.x,2) + pow(accel.acceleration.z,2)))*(180/3.14159);
        }
          else if ((angle_x>=0) & (angle_y<=0)){
            tilt_0 =180 - ( atan(accel.acceleration.y/sqrt(pow(accel.acceleration.x,2) + pow(accel.acceleration.z,2)))*(180/3.14159) );
          }
            else if ((angle_x<=0) & (angle_y<=0)){
              tilt_0 = -1*180 - ( atan(accel.acceleration.y/sqrt(pow(accel.acceleration.x,2) + pow(accel.acceleration.z,2)))*(180/3.14159) );
            }
              else if ((angle_x<=0) & (angle_y>=0)){
                tilt_0 = atan(accel.acceleration.y/sqrt(pow(accel.acceleration.x,2) + pow(accel.acceleration.z,2)))*(180/3.14159);
              }

      previous_tilt=tilt_0;

      //tilt_01=atan(accel.acceleration.y/accel.acceleration.x);//encoder_count;
      //tilt_02=atan(accel.acceleration.x/accel.acceleration.y);//encoder_count;
      Serial.print("Start tilt meas at t0 at (deg) ");Serial.println(tilt_0);
      Serial.print("With rotor angle at t0 at (deg) ");Serial.println(Angle_field_0);
      Serial.print("Angle target (deg) = ");Serial.println(Angle_field_target);

      //Serial.print(" and ");Serial.println(tilt_02);
      //g0x= accel.acceleration.x;
      //g0y= accel.acceleration.y;
      //Serial.print("Motor.Angle_target=");Serial.println(Motor.Angle_target);  
      //Serial.print("Angle target= ");Serial.print(Motor.Angle_target);
      //Serial.print(" encoder= ");Serial.println(encoder_count); //Serial.print(" shift = ");Serial.println(encoder_Shift);
      //encoder_count_prev=atoi(ms.GetCapture (captureBufA,1));   
      //encoder_count_prev=encoder_count;  
      //Motor.Ashift=encoder_Shift;  
      Motor.State=16; 
    }

    char resultField1s=ms.Match ("(sField)(%+?%-?%d+.%d+)(;)",0);
    if (resultField1s == REGEXP_MATCHED){
      char captureBufField1s [20];
      theta_star=0;
      previous_tstar=0;
      //Angle_field_0=encoder_count*2*M_PI/tour;
      Angle_field_0=encoder_count;

      if (accel.acceleration.x>=0 && accel.acceleration.y>=0){
        tilt_0=atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
      }
        else if (accel.acceleration.x>=0 && accel.acceleration.y<=0){
          tilt_0=atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
        }
          else if (accel.acceleration.x<=0 && accel.acceleration.y<=0){
            tilt_0=-1*M_PI+atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
          }
            else if (accel.acceleration.x<=0 && accel.acceleration.y>=0){
              tilt_0=M_PI+atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
            } 

      
      Serial.print("Start tilt meas at t0 at ");Serial.println(tilt_0);
      //Serial.print("With rotor angle at t0 at ");Serial.println(Angle_field_0);
 
      Motor.State=17; 
    }
  }


//////////////////////////////////////////////////////////////////////////

 if (Poke){ 

    unsigned long currentMillis1 = millis();
    if (currentMillis1 - previousMillis1 <= 1000){   //1/this value=frequency at which value is send to broadcast
      //previousMillis1 = currentMillis1;    // Save timestamp
      //Serial.println("POKE");
      tp.DotStar_SetPower(true);
      tp.DotStar_SetPixelColor(0,0,100);
      tp.DotStar_Show();  
    }
    else {tp.DotStar_SetPower(false);Poke=0;} 

  }

  
  unsigned long currentMillis2 = millis();
  dtheta=encoder_count-previous_encoder_count;
  if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  else if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
  else {Motor.Speed=dtheta;}
  previous_encoder_count=encoder_count;
  dt=currentMillis2-previousMillis2;
  previousMillis2 = currentMillis2;

  Speed_raw=((float)(Motor.Speed*1000)/((float)dt));


  //exponential moving average (EMA):
  current_avg=(alpha_EMA*Speed_raw)+((1-alpha_EMA)*last_avg);
  last_avg=current_avg;

  //double exponential moving average (DEMA):
  current_avg_double=(alpha_EMA*current_avg)+((1-alpha_EMA)*last_avg_double);
  last_avg_double=current_avg_double;
  DEMA_avg=(2*current_avg)-current_avg_double;


 if (Motor.State==0){ // "soft" mode
    //tp.DotStar_SetPower(false);  
    MotorOFF();
    encoder_count_prev=encoder_count;
    Motor.Angle_target=encoder_count_prev;
  }  

  if (Motor.State==1){  //"stiff" mode
       

    if (tour-Motor.Angle_target>round(tour/2)){Motor.Angle_target=tour+Motor.Angle_target;}
    if (Motor.Angle_target-encoder_count>round(tour/2)){encoder_count=tour+encoder_count;}
  
    unsigned long currentMillis4 = millis();
    if (currentMillis4 - previousMillis4 >= 2){   //PID computed value updated every 3ms
      previousMillis4 = currentMillis4;    // Save timestamp                      
      
      // if (rel_count>0){
      //   if (encoder_count==Motor.Angle_target)
      //   Motor.Angle_target=; // The "goal" the PID controller tries to "reach", 
      // }   
      //}

      pidcontroller.setpoint(Motor.Angle_target);

      Motor.PWM = pidcontroller.compute(encoder_count); 
      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,5);}
      else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),5);}
     
      //motor(Motor.PWM); //not working

      if (encoder_count>tour){encoder_count=encoder_count-tour;}
    }    
  } 


/////////////////////////////////////////////////////////////////////////////////////////////
  if (Motor.State==2){ // "spring" mode
      //Serial.println("Inside mode spring");
      

      // dtheta=encoder_count-previous_encoder_count;
      // if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      // else if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      // else {Motor.Speed=dtheta;}
      // previous_encoder_count=encoder_count;

      theta_star=theta_star+Motor.Speed;


    if (test<100){ //initial kick
      pidcontroller.setpoint(theta_eq+theta_0); // The "goal" the PID controller tries to "reach", 
      Motor.PWM = pidcontroller.compute(encoder_count); 
      test=test+1;
    }
    else {

      
      // if  ((theta_eq-theta_0>=1) & (theta_eq+theta_0<tour)){
      //   theta_star=encoder_count-theta_eq;
      //   Motor.Speed=dtheta;
      // } 
      // else {
      //   if (theta_eq-theta_0<1){
      //     if (encoder_count>theta_eq+(3*theta_0)){theta_star=encoder_count-theta_eq-tour;}else{theta_star=encoder_count-theta_eq;}
      // }
      //   if (theta_eq+theta_0>tour){
      //     if (encoder_count<theta_eq-(3*theta_0)){theta_star=tour-theta_eq+encoder_count;}else{theta_star=encoder_count-theta_eq;}
      //   }
      // }

      // else if (theta_eq-theta_0<1){
      //   if (dtheta>tour/2){state=~state;Motor.Speed=encoder_count-tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      //   if (dtheta<-tour/2){state=~state;Motor.Speed=encoder_count+tour-previous_encoder_count;}//Serial.println(state);}//Serial.print(" ");}
      //   if (state){theta_star=encoder_count-theta_eq-tour;}
      //     else{theta_star=encoder_count-theta_eq;Motor.Speed=dtheta;}
      // }
      // else if (theta_eq+theta_0>tour){
      //   if (encoder_count<theta_eq-theta_0){theta_star=tour-theta_eq+encoder_count;}else{theta_star=encoder_count-theta_eq;}
      // }

      Motor.PWM=((-1)*k*(theta_star)/1000)+(bias*Motor.Speed/100);
    }

    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      //Motor.PWM=Motor.PWM+bias;
      motor_ccw(Motor.PWM,20);}
    else{ // else we move it in a counter clockwise direction
      //Motor.PWM=Motor.PWM-bias;
      motor_cw(abs(Motor.PWM),20);}

  }

  if (Motor.State==3){ // "cogue torque + friction calibration" mode
   unsigned long currentMillis6 = millis();
   if (currentMillis6 - previousMillis6 >= Cal_time){//4){   //1/this value=frequency at which messages are sent outward
    previousMillis6 = currentMillis6; 
    incr_cal=incr_cal+Cal_interval;  
    if (incr_cal<256){
      Motor.PWM=incr_cal;
      motor_cw(abs(Motor.PWM),0);}
    else{
      Motor.State=0;
      incr_cal=(-1)*Cal_interval;} 
   }
  } 

  if (Motor.State==10){ // "cogue torque + friction calibration" mode slow decay
   unsigned long currentMillis12 = millis();
   if (currentMillis12 - previousMillis12 >= Cal_time){//4){   //1/this value=frequency at which messages are sent outward
    previousMillis12 = currentMillis12; 
    incr_cal=incr_cal+Cal_interval;  
    if (incr_cal<256){
      Motor.PWM=incr_cal;
      motor_cw_s(abs(Motor.PWM),0);}
    else{
      Motor.State=0;
      incr_cal=(-1)*Cal_interval;} 
   }
  } 

  if (Motor.State==11){ // "cogue torque + friction calibration" mode slow decay
   unsigned long currentMillis13 = millis();
   if (currentMillis13 - previousMillis13 >= Cal_time){//4){   //1/this value=frequency at which messages are sent outward
    previousMillis13 = currentMillis13; 
    incr_cal=incr_cal+Cal_interval;  
    if (incr_cal<256){
      Motor.PWM=incr_cal;
      motor_cw_s2(abs(Motor.PWM),0);}
    else{
      Motor.State=0;
      incr_cal=(-1)*Cal_interval;} 
   }
  } 

//////////////////////////////////////////////////////
  if (Motor.State==4){ // "Handcheck" mode
    
    theta_star=theta_star+Motor.Speed;
    
    if (sol_mode==1){ //master mode

      unsigned long currentMillis8 = millis();
      if (currentMillis8 - previousMillis8 >= (int)refresh){//4){   //1/this value=frequency at which messages are sent outward
        previousMillis8 = currentMillis8; 
        sol_pulse=M_PI*1000/(float)(refresh*Sample_Hand);
        func_pos=sol_amp*sin((float)(time_count*sol_pulse)/1000);
        time_count=time_count+round(sol_period/Sample_Hand);
  
        if (time_count<=(int)refresh*Sample_Hand){pidcontroller.setpoint(sol_coef0*func_pos);}//Serial.println(func_pos);}
        else {pidcontroller.setpoint(0);}//Serial.println(0);}
              
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckS[10];
        memset(bufcheckS, 0, 10); 
        sprintf(bufcheckS,"M%i;",theta_star);       
        Udp.print(bufcheckS);
        Udp.endPacket();
      
      }

      //Serial.println(encoder_count);
      //Serial.println(theta_star);
      //Serial.println(Motor.PWM);
      Motor.PWM = pidcontroller.compute(theta_star);
      //Serial.println(func_pos);

      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
        motor_ccw(Motor.PWM,20);}
      else{ // else we move it in a counter clockwise direction
        motor_cw(abs(Motor.PWM),20);}


      unsigned long currentMillis7 = millis();    
      if (currentMillis7- previousMillis7 >= sol_speed_g){
      
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheck[7]={'O',';'};  
        Udp.print(bufcheck);
        Udp.endPacket();
        tp.DotStar_SetPower(false); 
      }
          
      
      if ((time_count>(refresh*Sample_Hand)) && (currentMillis7- previousMillis7 >= sol_speed_g)){  
        Motor.State=1;
        time_count=0; 
      } 
    
  }

    if (sol_mode==2){// slave mode
 
      pidcontroller.setpoint(sol_coef[Neighbor_count-1]*Master_dtheta);

      // if (Neighbor_count<sol_n){
      //   Udp.beginPacket(udpAddressN, localPort); 
      //   char bufcheckS[15];
      //   memset(bufcheckS, 0, 15); 
      //   sprintf(bufcheckS,"M%i/%i/%i;",Master_Address, Master_dtheta,Neighbor_count);       
      //   //Serial.println(bufcheckS);
      //   Udp.print(bufcheckS);
      //   Udp.endPacket();
      // }

      Serial.print(Master_dtheta);Serial.print(' ');
      Serial.println(Neighbor_count);
      Motor.PWM = pidcontroller.compute(theta_star);

      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
        motor_ccw(Motor.PWM,20);}
      else{ // else we move it in a counter clockwise direction
        motor_cw(abs(Motor.PWM),20);}
        
    }
       
  } 
///////////////////////////////////////////////////////////////////////////////

 if (Motor.State==5){ // "Hand Roll" mode
 
  theta_star=theta_star+Motor.Speed;

  if (Motor.Address==AddressLead){ //lead mode
    
    
    //pidcontroller.setpoint(0);

    unsigned long currentMillis7 = millis();    
    if (currentMillis7- previousMillis7 >= 5){
        pidcontroller_speed.setpoint(speed_roll);
        speed_roll_meas=theta_star-previous_tstar;
        Udp.beginPacket(udpAddressN, localPort); 
        char bufcheckS[10];
        memset(bufcheckS, 0, 10); 
        sprintf(bufcheckS,"MR%i;",theta_star);       
        Udp.print(bufcheckS);
        Udp.endPacket();
        //Serial.print("Data sent V=");Serial.println(speed_roll_meas);    
        //tp.DotStar_SetPower(false); 
        Motor.PWM = pidcontroller_speed.compute(speed_roll_meas);
        previous_tstar=theta_star;
      }


  } else{  //slave mode

    pidcontroller.setpoint(Master_dtheta);
    Motor.PWM = pidcontroller.compute(theta_star);

    }

    if (Neighbor_address_int==0){Motor.PWM =0;}
 
  if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
    motor_ccw_s(Motor.PWM,0);}
  else{ // else we move it in a counter clockwise direction
    motor_cw_s(abs(Motor.PWM),0);}
 }


  if (Motor.State==6){ // "Direct Roll" mode
  
    theta_star=theta_star+Motor.Speed;    

    unsigned long currentMillis9 = millis();    
    if (currentMillis9- previousMillis9 >= (int)1000*dt_DR){
    //if (currentMillis9- previousMillis9 >= speed_roll){
        pidcontroller_speed.setpoint(speed_roll);
        //pidcontroller.setpoint(100);
        previousMillis9 = currentMillis9; 
        speed_roll_meas=(theta_star-previous_tstar)*dt_DR;
        Motor.PWM = pidcontroller_speed.compute(speed_roll_meas);
        previous_tstar=theta_star;
      }
  
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,20);}
    else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),20);}
  }

 
  if (Motor.State==7){ // "Direct Roll" mode
    
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,0);}
    else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),0);}
  }

  if (Motor.State==12){ // "Direct Roll" mode
    
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw_s(Motor.PWM,0);}
    else{ // else we move it in a counter clockwise direction
      motor_cw_s(abs(Motor.PWM),0);}
  }


  if (Motor.State==8){ // "Force soliton lead" mode

    unsigned long currentMillis10 = millis();    
    if (currentMillis10- previousMillis10 >= sol_speed_g){
    
      Udp.beginPacket(udpAddressN, localPort); 
      char bufcheck[7]={'O','F',';'};  
      Udp.print(bufcheck);
      Udp.endPacket();
      tp.DotStar_SetPower(false); 
      Motor.PWM=0;
      Serial.println("Neighbor Master CHECK sent");
      Motor.State=0;
    }
    //Serial.println(currentMillis10- previousMillis10);


    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,20);}
    else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),20);}
  }

  if (Motor.State==9){ // "Simple speed controled" mode
   
   theta_star=theta_star+Motor.Speed;    

    unsigned long currentMillis11 = millis();    
    if (currentMillis11- previousMillis11 >= 20){//(int)1000*dt_DR){
    //if (currentMillis9- previousMillis9 >= speed_roll){
        pidcontroller.setpoint(speed_roll);
        //pidcontroller.setpoint(100);
        previousMillis11 = currentMillis11; 
        speed_roll_meas=(theta_star-previous_tstar)*dt_DR;
        Motor.PWM = pidcontroller.compute(speed_roll_meas);
        previous_tstar=theta_star;
        //Serial.println(theta_star);   
      }

    if (abs(theta_star)>=Motor.Ashift){
      Serial.println("Rotor reached target displacement");   
      Motor.Angle_target=encoder_count;
      Motor.State=0;
    }  
  
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,20);}
    else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),20);}
  }

  if (Motor.State==13){
     MotorBRAKE(Motor.PWM);
   }

  if (Motor.State==14){
    // if (Motor.PWM>0){MotorDiffPWM_cw(Motor.PWM,Motor.Brake_val);}
    // else{MotorDiffPWM_ccw(Motor.PWM,Motor.Brake_val);}
    MotorDiffPWM(Motor.PWM,Motor.Brake_val);
   }


////////////////////////////////////////////
   if (Motor.State==15){ // "range Roll" mode in Slow current decay mode
  
    theta_star=theta_star+Motor.Speed;    

    unsigned long currentMillis14 = millis();    
    if (currentMillis14- previousMillis14 >= (int)1000*dt_DR){
    //if (currentMillis9- previousMillis9 >= speed_roll){
        
        //pidcontroller.setpoint(100);
        previousMillis9 = currentMillis14; 
        speed_roll_meas=(theta_star-previous_tstar)*dt_DR;

      if (!range_Init){

        if (speed_roll_meas>speed_roll+range_dtheta){
          pidcontroller_speed.setpoint(speed_roll+range_dtheta);
          Motor.PWM = pidcontroller_speed.compute(speed_roll_meas);
        } 
        else if (speed_roll_meas<speed_roll-range_dtheta){
          pidcontroller_speed.setpoint(speed_roll-range_dtheta);
          Motor.PWM = pidcontroller_speed.compute(speed_roll_meas);
        } 
        else {
          Motor.PWM = range_PWM;
        }
      }
      else{
        pidcontroller_speed.setpoint(speed_roll);
        Motor.PWM = pidcontroller_speed.compute(speed_roll_meas);
        if (speed_roll_meas==speed_roll){range_Init=false;}
      }

      previous_tstar=theta_star;

      }
  
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw_s(Motor.PWM,20);}
    else{ // else we move it in a counter clockwise direction
      motor_cw_s(abs(Motor.PWM),20);}
  }
////////////////////////////////////////////////////////////
 
  if (Motor.State==7){ // "Direct Roll" mode
    
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw(Motor.PWM,0);}
    else{ // else we move it in a counter clockwise direction
      motor_cw(abs(Motor.PWM),0);}
  }

  if (Motor.State==12){ // "Direct Roll" mode
    
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw_s(Motor.PWM,0);}
    else{ // else we move it in a counter clockwise direction
      motor_cw_s(abs(Motor.PWM),0);}
  }

  ////////////////////////////////////////////
  if (Motor.State==16){

    //unsigned long currentMillis15 = millis(); 
      
    // if (currentMillis15- previousMillis15 >= (int)1000*dt_DR){


    // }

    unsigned long t_now = millis()-t_0;
          
    float gyro_x = gyro.gyro.x;
    float gyro_y = gyro.gyro.y;
    
    
    // Get raw acceleration values
    //float G_CONVERT = 16384;
    float accel_x = accel.acceleration.x;
    float accel_y = accel.acceleration.y;
    float accel_z = accel.acceleration.z;

    // Get angle values from accelerometer
    float RADIANS_TO_DEGREES = 180/3.14159;
  //  float accel_vector_length = sqrt(pow(accel_x,2) + pow(accel_y,2) + pow(accel_z,2));
    float accel_angle_y = atan(-1*accel_x/sqrt(pow(accel_y,2) + pow(accel_z,2)))*RADIANS_TO_DEGREES;
    float accel_angle_x = atan(accel_y/sqrt(pow(accel_x,2) + pow(accel_z,2)))*RADIANS_TO_DEGREES;
    
    // Compute the (filtered) gyro angles
    float dt =(t_now - previous_t)/1000.0;
    float gyro_angle_x = gyro_x*dt + previous_x_angle;
    float gyro_angle_y = gyro_y*dt + previous_y_angle;
    
    // // Compute the drifting gyro angles
    // float unfiltered_gyro_angle_x = gyro_x*dt + previous_x_gyro_angle;
    // float unfiltered_gyro_angle_y = gyro_y*dt + previous_y_gyro_angle;
    
    // Apply the complementary filter to figure out the change in angle - choice of alpha is
    // estimated now.  Alpha depends on the sampling rate...
    
    angle_x = alpha*gyro_angle_x + (1.0 - alpha)*accel_angle_x;
    angle_y = alpha*gyro_angle_y + (1.0 - alpha)*accel_angle_y;
    
    previous_t=t_now;
    previous_x_angle=angle_x;
    previous_y_angle=angle_y;
    previous_x_gyro_angle= gyro_angle_x ;
    previous_y_gyro_angle=gyro_angle_y;
    
    //tilt=180-angle_x;
    //define tilt angle from angle_x and in [-180,180] deg
    // if (angle_x>=0 && angle_y>=0){
    //   //angle_x = alpha*gyro_angle_x + (1.0 - alpha)*accel_angle_x;
    //   //angle_y = alpha*gyro_angle_y + (1.0 - alpha)*accel_angle_y;
    //   tilt=angle_x;
    //     }
    //       else if (angle_x>=0 && angle_y<=0){
    //         //angle_x = alpha*gyro_angle_x + (1.0 - alpha)*accel_angle_x;
    //         //angle_y = alpha*gyro_angle_y + (1.0 - alpha)*accel_angle_y;
    //         tilt=180-angle_x;
    //       }
    //         else if (angle_x<=0 && angle_y<=0){
    //           //angle_x = -1*M_PI+alpha*gyro_angle_x + (1.0 - alpha)*accel_angle_x;
    //           //angle_y = -1*M_PI+alpha*gyro_angle_y + (1.0 - alpha)*accel_angle_y;//-tilt_01;
    //           tilt=-1*180+angle_x;
    //         }
    //           else if (angle_x<=0 && angle_y>=0){
    //             //angle_x = M_PI+alpha*gyro_angle_x + (1.0 - alpha)*accel_angle_x;
    //             //angle_y = M_PI+alpha*gyro_angle_y + (1.0 - alpha)*accel_angle_y;
    //             tilt=angle_x;
    //           }
    if ((angle_x>=0) & (angle_y>=0)){
      tilt=angle_x;
        }
      else if ((angle_x>=0) & (angle_y<=0)){
        tilt=180-angle_x;
          }
        else if ((angle_x<=0) & (angle_y<=0)){
          tilt=-1*180-angle_x;
            }
          else if ((angle_x<=0) & (angle_y>=0)){
            tilt=angle_x;
              }

    

    //tilt=atan((accel.acceleration.y)/(accel.acceleration.x))*RADIANS_TO_DEGREES;

    // if (accel.acceleration.x>=0 && accel.acceleration.y>=0){
    //   tilt=atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
    // }
    //   else if (accel.acceleration.x>=0 && accel.acceleration.y<=0){
    //     tilt=atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
    //   }
    //     else if (accel.acceleration.x<=0 && accel.acceleration.y<=0){
    //       tilt=-1*M_PI+atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
    //     }
    //       else if (accel.acceleration.x<=0 && accel.acceleration.y>=0){
    //         tilt=M_PI+atan((accel.acceleration.y)/(accel.acceleration.x));//-tilt_01;
    //       }


      // dalpha_t=tilt-previous_tilt;
      // if (dalpha_t>M_PI){state_2=~state_2;dalpha=2*M_PI-(tilt-previous_tilt);}//Serial.println(state);}//Serial.print(" ");}
      // else if (dalpha_t<-M_PI){state_2=~state_2;dalpha=(previous_tilt-tilt)-2*M_PI;}//Serial.println(state);}//Serial.print(" ");}
      // else {dalpha=dalpha_t;}
      // previous_tilt=tilt;
      dalpha_t=tilt-previous_tilt;
      if (dalpha_t>180){state_2=~state_2;dalpha=2*180-(tilt-previous_tilt);}//Serial.println(state);}//Serial.print(" ");}
      else if (dalpha_t<-180){state_2=~state_2;dalpha=(previous_tilt-tilt)-2*180;}//Serial.println(state);}//Serial.print(" ");}
      else {dalpha=dalpha_t;}
      previous_tilt=tilt;

      tilt_star=tilt_star+dalpha;
      theta_star=theta_star-Motor.Speed;


      Angle_field = (float)theta_star-(tilt_star*((float)tour/(360)));
      //Angle_field = (int)Angle_field % tour;
      
      // //total=total+Angle_field[readIndex];
      // // readIndex = readIndex + 1;
      // // if (readIndex >= buffersize_angle_field) {readIndex = 0;}
      // // average = (total / buffersize_angle_field);
      // //Motor.PWM=-1*Motor.Max_Torque*sin((M_PI/tour)*(Angle_field-Angle_field_target));
      // //Motor.PWM=-1*(int)(2*Motor.Max_Torque/tour)*(int)(Angle_field-Angle_field_target);
      // //Motor.PWM=(int)(-1*255*(2/tour)*(Angle_field-Angle_field_target)) ;
      pidcontroller_speed.setpoint(Angle_field_target);
      // //Motor.PWM = pidcontroller_speed.compute(average);
      Motor.PWM =  -1*pidcontroller_speed.compute(Angle_field);
      // //coef=0.5*2*M_PI/tour
      //Motor.PWM=(-1*255*(2/tour)*(Angle_field-Angle_field_target)) ;

      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
        motor_ccw_s(Motor.PWM,0);}
      else{ // else we move it in a counter clockwise direction
        motor_cw_s(abs(Motor.PWM),0);}
    
  }


  if (Motor.State==18){
      time_wave=millis()-time_wave_0;
    
      Motor.PWM = U0+round(A*sin( (2*M_PI/period_wave) * ((float)time_wave/1000) + phi));

      if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
        motor_ccw_s(Motor.PWM,0);}
      else{ // else we move it in a counter clockwise direction
        motor_cw_s(abs(Motor.PWM),0);}
      
      Serial.println(Motor.PWM);  
  }

 if (Motor.State==19){
    
    if (randomize){
      unsigned long currentMillis16 = millis();
      if (currentMillis16 - previousMillis16 >= timeRand){//4){   //1/this value=frequency at which messages are sent outward
        previousMillis16 = currentMillis16;    // Save timestamp   
        RandNumber=random(0,2);
        if (RandNumber>0.5){Ub=Ub*(-1);}     
      }   
    }

    time_wave=millis()-time_wave_0;
    theta_star=theta_star+Motor.Speed;
    // we use K_t^+, the torque constante at positive load 
    
    signOfX = (DEMA_avg > 0) - (DEMA_avg < 0);

    //PWM_raw=round(H1*U0-(G*H2*(float)theta_star)+(H3*A*DEMA_avg)+(Amp*sin((pulsation*(float)time_wave)/1000)));
    PWM_raw=round((H1*Ub)+(H1*U0)+(H1*signOfX*U)-(G*H2*(float)theta_star)+(H3*A*DEMA_avg)+(Amp*sin((pulsation*(float)time_wave)/1000)));

    //PWM_raw=H1*U0-(G*H2*(float)theta_star)+(H3*A*PWM_Speed_raw)+(Amp*sin((pulsation*(float)time_wave)/1000));

    // //exponential moving average (EMA):
    // PWM_current_avg=(alpha_EMA*Motor.PWM)+((1-alpha_EMA)*PWM_last_avg);
    // PWM_last_avg=PWM_current_avg;

    // //double exponential moving average (DEMA):
    // PWM_current_avg_double=(alpha_EMA*PWM_current_avg)+((1-alpha_EMA)*PWM_last_avg_double);
    // PWM_last_avg_double=PWM_current_avg_double;
    // PWM_DEMA_avg=(2*PWM_current_avg)-PWM_current_avg_double;
    // Motor.PWM=round(PWM_DEMA_avg);
    
    Motor.PWM=PWM_raw;


    if (Motor.PWM>255){
      Motor.PWM=255;
    }

    if (Motor.PWM<-255){
      Motor.PWM=-255;
    }
  
    //Motor.PWM =0;
    
    if (Motor.PWM > 0){ // if the motor_pwm_value is greater than zero we rotate the  motor in clockwise direction
      motor_ccw_s(Motor.PWM,0);}
    else{ // else we move it in a counter clockwise direction
      motor_cw_s(abs(Motor.PWM),0);}


    // Serial.print(255);
    // Serial.print(",\t");
    // Serial.print(-255);
    // Serial.print(",\t");
    // Serial.print(Motor.PWM);
    // Serial.print(",\t");
    // Serial.print(Speed_raw/10);
    // Serial.print(",\t");
    // Serial.println(DEMA_avg/10);

  }

  ////////////////////////Data format and send
  unsigned long currentMillis5 = millis();
  if (currentMillis5 - previousMillis5 >= 4){//4){   //1/this value=frequency at which messages are sent outward
    previousMillis5 = currentMillis5;    // Save timestamp   
    // Serial.println(currentMillis5);
    // Motor.Angle=map(encoder_count,round(tour/2),tour+round(tour/2),0,1023);
    // Motor.Angle=(Motor.Angle+512)%1023;
    Motor.Angle=encoder_count;
    
    // Serial.print(0);Serial.print(" ");
    // Serial.print(tour);Serial.print(" ");
    // Serial.print(Motor.Speed*100);Serial.print(" ");
    // Serial.print(theta_star);Serial.print(" ");
    // Serial.println(Motor.Angle);

    //ThetaG=atan2((double)accel.acceleration.y,(double)accel.acceleration.x)-(M_PI/4);
    //if (ThetaG<=-M_PI){ThetaG=M_PI/4-abs(ThetaG+M_PI)+(3*M_PI/4);} //rotation of pi/4 to take the plug up as 0 reference
    //Serial.println(ThetaG);
  
    // create JSON object 
    // Declare a buffer to hold the result
    char output[256];//[192];// recomended size. can be decreased down to 144 max. https://arduinojson.org/v6/assistant/
    StaticJsonDocument<256> motion;
    //char output[192];// recomended size. can be decreased down to 144 max. https://arduinojson.org/v6/assistant/
    //StaticJsonDocument<192> motion;

// // //current sensor
//     shuntvoltage = ina219.getShuntVoltage_mV();
//     busvoltage = ina219.getBusVoltage_V();
//     current_mA = ina219.getCurrent_mA();
//     //power_mW = ina219.getPower_mW();
//     //loadvoltage = busvoltage + (shuntvoltage / 1000);
  
  // Serial.print("Bus Voltage:   "); Serial.print(busvoltage); Serial.println(" V");
  // Serial.print("Shunt Voltage: "); Serial.print(shuntvoltage); Serial.println(" mV");
  // Serial.print("Load Voltage:  "); Serial.print(loadvoltage); Serial.println(" V");
  // Serial.print("Current:       "); Serial.print(current_mA); Serial.println(" mA");
  // Serial.print("Power:         "); Serial.print(power_mW); Serial.println(" mW");
  // Serial.println("");
  // //////////////////////////////////////////////////////



    // Compute the length of the minified JSON document
    //      int len1=measureJson(motion);
    //      Serial.print("JSON document size:");Serial.println(len1);
    motion["d"] = Motor.Address;
    motion["t"] = millis();
    motion["A"] = Motor.Angle; 
    //motion["A"] = Angle_field;//Angle_field[readIndex];//average;//
    //motion["C"] = angle_x;//Angle_field;//Angle_field[readIndex];//average;// 
    //motion["D"] = angle_y;
    //motion["R"] = tilt_star;
    //motion["G"] = Angle_field;//tilt; 
    //motion["H"] = theta_star;// 
    motion["x"] = accel.acceleration.x;
    motion["y"] = accel.acceleration.y;
    //motion["z"] = accel.acceleration.z;
    motion["u"] = gyro.gyro.x;
    motion["v"] = gyro.gyro.y;
    //motion["w"] = gyro.gyro.z;

    //motion["F"] = tilt_star;//Angle_field;
    
    //Serial.println(tilt_1);
    //motion["G"] = tilt_2;//Angle_field;
    motion["P"] = Poke;
    motion["T"] = Motor.PWM;
    motion["S"] = Motor.State;
    motion["B"] = ((tp.GetBatteryVoltage()-3.5)/0.70)*100;

    char buf[10];
    sprintf(buf,udpAddress);
    motion["ipo"]=buf;
    //Serial.println(buf);
    
    //get current data when INA 219 is in the hardware
    // motion["I"]=current_mA;
    // //motion["Ul"]=loadvoltage;
    // motion["Ub"]=busvoltage;
    // motion["Us"]=shuntvoltage;

    // //get magnetometer data (uncomment sensor update at the beginning of void(loop) if needed)
    // //Cartesian
    // Serial.print(Tlv493dMagnetic3DSensor.getX());
    // Serial.print(" ; ");
    // Serial.print(Tlv493dMagnetic3DSensor.getY());
    // Serial.print(" ; ");
    // Serial.println(Tlv493dMagnetic3DSensor.getZ());
    // //Spherical
    // Serial.print(Tlv493dMagnetic3DSensor.getAmount());
    // Serial.print(" ; ");
    // Serial.print(Tlv493dMagnetic3DSensor.getAzimuth());
    // Serial.print(" ; ");
    // Serial.println(Tlv493dMagnetic3DSensor.getPolar());

    //Serial.println(lsm6dsox.rawAccX);
    
    serializeJson(motion,output);
    //serializeJson(motion,Serial);
    //Serial.println();
    //Serial.print(" ");Serial.println(micros());
    
    //char buffer1[128];
    //memset(buffer1, 0, 6);   
    Udp.beginPacket(udpAddress, outPort);   
    //itoa(Motor.Angle, buffer1,10);
    //Udp.print("A");
    Udp.print(output);
    Udp.endPacket();
    // Serial.print(" ");Serial.println(micros());
    //Serial.println(Motor.Angle);
    //Serial.print(currentMillis5); Serial.print(" "); Serial.println(udpAddress);
    }///loop current millis
//
//    unsigned long currentMillis6 = millis();
//    if (currentMillis6 - previousMillis6 >= 10000){   //PID computed value updated every 3ms
//        previousMillis6 = currentMillis6;    // Save timestamp   
//    
//        char bufBat[8];
//        memset(bufBat, 0, 8);
//        bufBat.add(((tp.GetBatteryVoltage()-3.5)/0.70)*100);
//        Udp.beginPacket(udpAddress, outPort);   
//        Udp.print(bufBat);
//        Udp.endPacket();   
//    }
//  //Serial.print(" ");Serial.println(millis());

  // for serial live plotter (works with arduino IDE)
   unsigned long currentMillis17 = millis();
   if (currentMillis17 - previousMillis17 >= 200){//4){   //1/this value=frequency at which messages are sent outward
     previousMillis17 = currentMillis17;    // Save timestamp   
    Serial.print(255);
    Serial.print(",\t");
    Serial.print(-255);
    Serial.print(",\t");
    Serial.print(Motor.PWM);
    Serial.print(",\t");
    //Serial.print(Speed_raw/10);
    Serial.print(Motor.Angle);
    Serial.print(",\t");
    Serial.println(DEMA_avg/10);
  //   Serial.print("S_avg= ");Serial.print(S_avg);
  //   Serial.print("step, t_avg= ");Serial.print(t_avg);
  //   Serial.print(" ms, Speed_avg= ");Serial.print(Speed_avg);
  //   //Serial.print("dt= ");Serial.print(dt);
  //   Serial.print(" step/s, PWM= ");Serial.print(Motor.PWM);
  //   Serial.print(" Spring term ");Serial.println(round(G*H2*(float)theta_star));
  //   //Serial.print(" H3*A*(Motor.Speed/dt)= "); Serial.println(round(H3*A*((float)Motor.Speed*1000/(float)dt)));
   }

}   //end void loop